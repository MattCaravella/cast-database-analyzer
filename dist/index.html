<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAST Database Analyzer</title>
    <!-- CACHE BUSTER v1.3.4 - ALL PROMPT() CALLS REMOVED -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- PDF.js for automatic PDF text extraction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Configure PDF.js worker
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>
    <style>
        :root {
            --bg-primary: #0b0d11;
            --bg-secondary: #1a1f28;
            --bg-tertiary: #252d3a;
            --bg-quaternary: #2d3748;
            --text-primary: #f7fafc;
            --text-secondary: #cbd5e0;
            --text-muted: #9ca3af;
            --accent: #3182ce;
            --accent-hover: #2b77cb;
            --accent-light: rgba(49, 130, 206, 0.1);
            --border: #4a5568;
            --border-light: #2d3748;
            --success: #38a169;
            --success-light: rgba(56, 161, 105, 0.1);
            --warning: #ed8936;
            --error: #e53e3e;
            --shadow: rgba(0, 0, 0, 0.25);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            background-color: var(--bg-secondary);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
        }

        .search-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            max-width: 500px;
        }

        #global-search {
            flex: 1;
            padding: 0.5rem 1rem;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        #global-search:focus {
            outline: none;
            border-color: var(--accent);
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 500;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            background-color: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        .btn:hover { background-color: var(--accent-hover); }
        .btn-warning { background-color: var(--warning); }
        .btn-warning:hover { background-color: #ff7043; }
        .btn-sm { padding: 0.3rem 0.8rem; font-size: 0.85rem; }

        main {
            flex: 1;
            display: flex;
            flex-direction: row;
            padding: 2rem;
            gap: 2rem;
            overflow: hidden;
        }

        .source-tiles-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            overflow-y: auto;
            overflow-x: hidden;
            padding-bottom: 1rem;
            max-height: 900px; /* 3 rows Ã— 280px height + gaps */
            flex: 0 0 60%; /* Take 60% of the width */
            max-width: 60%;
            align-content: flex-start;
        }

        .source-tiles-container::-webkit-scrollbar {
            width: 8px;
        }

        .source-tiles-container::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        .source-tiles-container::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        .source-tile {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            width: calc(25% - 0.75rem); /* 4 tiles per row minus gaps */
            min-width: 240px;
            height: 280px;
            flex-shrink: 0;
        }

        .source-tile h3 {
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .tile-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }

        .tile-title {
            font-size: 1.1rem;
            font-weight: bold;
            flex: 1;
        }

        .tile-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .tile-delete-btn {
            background: var(--error);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .tile-delete-btn:hover {
            opacity: 1;
        }

        .create-tile {
            border: 2px dashed var(--accent);
            background-color: rgba(0, 122, 204, 0.05);
        }

        .create-tile h3 {
            color: var(--accent);
        }

        .tile-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .tile-controls {
            display: flex;
            gap: 0.5rem;
        }

        .rename-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .rename-btn:hover {
            background: var(--border);
        }

        .drop-zone {
            flex: 1;
            border: 2px dashed var(--border);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            background-color: var(--bg-tertiary);
            min-height: 80px;
        }

        .drop-zone:hover {
            border-color: var(--accent);
            background-color: rgba(0, 122, 204, 0.1);
        }

        .drop-zone.dragover {
            border-color: var(--accent);
            background-color: rgba(0, 122, 204, 0.2);
        }

        .drop-zone p {
            color: var(--text-secondary);
            text-align: center;
            font-size: 0.85rem;
            line-height: 1.2;
        }

        .tile-stats {
            margin-top: 0.5rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.25rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .file-count-link {
            color: var(--accent);
            cursor: pointer;
            text-decoration: underline;
        }

        .file-count-link:hover {
            color: var(--accent-hover);
        }

        .file-list {
            display: none; /* Hidden by default */
        }

        .file-list-item {
            padding: 0.25rem 0;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-remove-btn {
            background: var(--error);
            color: white;
            border: none;
            border-radius: 3px;
            padding: 0.2rem 0.5rem;
            font-size: 0.7rem;
            cursor: pointer;
            margin-left: 0.5rem;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .file-remove-btn:hover {
            opacity: 1;
        }

        .analysis-container {
            flex: 1; /* Take remaining space (40%) */
            background-color: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 300px; /* Ensure minimum readable width */
        }

        .tabs {
            display: flex;
            background-color: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
        }

        .tab-btn {
            padding: 1rem 2rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }

        .tab-btn:hover { color: var(--text-primary); }

        .tab-btn.active {
            color: var(--text-primary);
            border-bottom-color: var(--accent);
        }

        .tab-content {
            flex: 1;
            overflow: hidden;
        }

        .tab-pane {
            display: none;
            height: 100%;
            flex-direction: column;
        }

        .tab-pane.active { display: flex; }

        .analysis-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .analysis-header h3 {
            font-size: 1rem;
            font-weight: 500;
        }

        .results-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .results-grid {
            display: grid;
            gap: 0.5rem;
        }

        .result-item {
            padding: 0.5rem 1rem;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
            display: grid;
            grid-template-columns: 1fr auto auto;
            align-items: center;
            gap: 1rem;
        }

        .result-item:hover {
            background-color: rgba(0, 122, 204, 0.1);
        }

        footer {
            background-color: var(--bg-secondary);
            border-top: 1px solid var(--border);
            padding: 0.5rem 2rem;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .progress-container {
            margin-top: 0.5rem;
            display: none; /* Hidden by default */
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: var(--bg-tertiary);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid var(--border);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, var(--success) 100%);
            transition: width 0.3s ease;
            width: 0%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .progress-text {
            margin-top: 0.25rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-align: center;
        }

        #progress-info { color: var(--accent); }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-tertiary); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        input[type="file"] { display: none; }

        /* Resizer for analysis container */
        .resize-handle {
            height: 4px;
            background: var(--border);
            cursor: ns-resize;
            position: relative;
        }

        .resize-handle:hover {
            background: var(--accent);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: var(--bg-secondary);
            margin: 15% auto;
            padding: 2rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            width: 80%;
            max-width: 600px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .modal-close {
            float: right;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal h3 {
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .modal-file-item {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border);
            color: var(--text-secondary);
        }

        .modal-file-item:last-child {
            border-bottom: none;
        }

        #search-summary {
            padding: 1rem;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
            margin-bottom: 1rem;
            font-size: 1rem;
            line-height: 1.5;
        }

        #search-results-list {
            max-height: 400px;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .search-result-tile {
            margin-bottom: 1.5rem;
            padding: 0.5rem;
            border-left: 3px solid var(--accent);
            background-color: var(--bg-tertiary);
            border-radius: 4px;
        }

        .search-result-tile h4 {
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .search-result-file {
            margin-left: 1rem;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            background-color: var(--bg-quaternary);
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        /* Input Modal for Tile Names */
        .input-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
        }

        .input-modal-content {
            background-color: var(--bg-secondary);
            margin: 25% auto;
            padding: 2rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            width: 400px;
            max-width: 90%;
        }

        .input-modal h3 {
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .input-modal input {
            width: 100%;
            padding: 0.75rem;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1rem;
            margin-bottom: 1rem;
        }

        .input-modal input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .input-modal-buttons {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        .btn-cancel {
            background-color: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .btn-cancel:hover {
            background-color: var(--border);
        }
    </style>
</head>
<body>
    <div id="app">
        <header>
            <h1>CAST Database Analyzer</h1>
            <div class="search-container">
                <input type="text" id="global-search" placeholder="Search for phone, email, IP, or any identifier..." />
                <button class="btn btn-sm" onclick="performGlobalSearch()">Search All Files</button>
            </div>
            <div class="header-controls">
                <button class="btn" onclick="loadDatabase()">Load Database</button>
                <button class="btn" onclick="saveDatabase()">Save Database</button>
                <button class="btn btn-warning" onclick="clearAll()">Clear All</button>
            </div>
        </header>

        <main>
            <div class="source-tiles-container" id="source-tiles-container">
                <div class="source-tile create-tile" id="create-source-tile">
                    <h3>Create Source Tile</h3>
                    <div class="drop-zone" data-source="create">
                        <p>Drag and drop files here or click to browse</p>
                        <input type="file" multiple accept=".csv,.xlsx,.xls,.txt,.html,.pdf">
                    </div>
                </div>
            </div>

            <div class="resize-handle" id="resize-handle"></div>

            <div class="analysis-container" id="analysis-container">
                <div class="tabs">
                    <button class="tab-btn active" data-tab="phones">Phone Numbers</button>
                    <button class="tab-btn" data-tab="emails">Email Addresses</button>
                    <button class="tab-btn" data-tab="ips">IP Addresses</button>
                </div>

                <div class="tab-content">
                    <div id="phones-tab" class="tab-pane active">
                        <div class="analysis-header">
                            <h3>Common Phone Numbers (Click to Export All Occurrences)</h3>
                            <button class="btn btn-sm" onclick="exportData('phones')">Export CSV</button>
                        </div>
                        <div class="results-container">
                            <div class="results-grid" id="phones-results"></div>
                        </div>
                    </div>

                    <div id="emails-tab" class="tab-pane">
                        <div class="analysis-header">
                            <h3>Common Email Addresses (Click to Export All Occurrences)</h3>
                            <button class="btn btn-sm" onclick="exportData('emails')">Export CSV</button>
                        </div>
                        <div class="results-container">
                            <div class="results-grid" id="emails-results"></div>
                        </div>
                    </div>

                    <div id="ips-tab" class="tab-pane">
                        <div class="analysis-header">
                            <h3>Common IP Addresses (Click to Export All Occurrences)</h3>
                            <button class="btn btn-sm" onclick="exportData('ips')">Export CSV</button>
                        </div>
                        <div class="results-container">
                            <div class="results-grid" id="ips-results"></div>
                        </div>
                    </div>

                </div>
            </div>
        </main>

        <footer>
            <div class="status-bar">
                <span id="status-text">Ready</span>
                <span id="progress-info"></span>
            </div>
            <div class="progress-container" id="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div class="progress-text" id="progress-text"></div>
            </div>
        </footer>
    </div>

    <!-- File List Modal -->
    <div id="fileModal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeFileModal()">&times;</span>
            <h3 id="modal-title">Files in Tile</h3>
            <div id="modal-file-list"></div>
        </div>
    </div>

    <!-- Search Results Modal -->
    <div id="searchModal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeSearchModal()">&times;</span>
            <h3 id="search-modal-title">Search Results</h3>
            <div id="search-summary"></div>
            <div id="search-results-list"></div>
            <div style="margin-top: 20px; text-align: center;">
                <button class="btn" id="export-search-results-btn">Export All Occurrences</button>
            </div>
        </div>
    </div>

    <script>
        // Data storage
        let sourceTiles = new Map(); // Map of tileId -> { name, files: [], phones: new Set(), emails: new Set(), ips: new Set(), phoneRows: new Map(), emailRows: new Map(), ipRows: new Map() }
        let tileCounter = 0;
        let currentInputCallback = null;
        let pendingFiles = null;
        
        // Check if we're in Electron and get the API
        const isElectron = window.electron && window.electron.isElectron;
        console.log('Running in Electron mode:', isElectron);
        
        // Pre-compiled regex patterns for better performance
        const patterns = {
            phone: [
                // Standard US phone formats - more flexible for all valid numbers
                // Allow any area code (000-999) and exchange (000-999)
                /(?:^|[^\d])(\d{3}[-.\s]?\d{3}[-.\s]?\d{4})(?:[^\d]|$)/g,
                // Parentheses format
                /(?:^|[^\d])\((\d{3})\)[-.\s]?(\d{3})[-.\s]?(\d{4})(?:[^\d]|$)/g,
                // 11 digits with leading 1
                /(?:^|[^\d])1[-.\s]?(\d{3})[-.\s]?(\d{3})[-.\s]?(\d{4})(?:[^\d]|$)/g,
                // International format with plus sign (+1xxxxxxxxxx)
                /\+1(\d{10})(?:[^\d]|$)/g,
                // Continuous 10 digits - optimized for CSV
                /(?:^|[^\d])(\d{10})(?:[^\d]|,|$)/g,
                // Continuous 11 digits (with leading 1) - optimized for CSV
                /(?:^|[^\d])(1\d{10})(?:[^\d]|,|$)/g,
                // CSV format - number between commas (fastest for CSV data)
                /,(\d{10,11}),/g,
                // CSV format - number at start of line
                /^(\d{10,11}),/gm,
                // CSV format - number at end of line
                /,(\d{10,11})$/gm
            ],
            email: /\b[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*\b/g,
            ipv4: /\b(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\b/g,
            ipv6: /\b(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}\b|\b(?:[0-9a-fA-F]{1,4}:){1,7}:\b/g // Simplified for performance
        };
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            setupDragAndDrop();
            setupTabs();
            setupResizer();
            setupInputModal();
        });

        // Input Modal Functions
        function setupInputModal() {
            const inputField = document.getElementById('input-modal-field');
            if (inputField) {
                inputField.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        confirmInputModal();
                    }
                });
            }
        }

        function showInputModal(title, placeholder = '', callback) {
            const modal = document.getElementById('inputModal');
            const titleElement = document.getElementById('input-modal-title');
            const inputField = document.getElementById('input-modal-field');
            
            if (!modal || !titleElement || !inputField) {
                console.error('Input modal elements not found');
                return;
            }
            
            titleElement.textContent = title;
            inputField.placeholder = placeholder;
            inputField.value = '';
            currentInputCallback = callback;
            
            modal.style.display = 'block';
            setTimeout(() => inputField.focus(), 100);
        }

        function closeInputModal() {
            const modal = document.getElementById('inputModal');
            if (modal) {
                modal.style.display = 'none';
            }
            currentInputCallback = null;
            pendingFiles = null;
        }

        function confirmInputModal() {
            const inputField = document.getElementById('input-modal-field');
            if (!inputField) return;
            
            const value = inputField.value.trim();
            
            if (value && currentInputCallback) {
                currentInputCallback(value);
            }
            
            closeInputModal();
        }

        // Setup tab functionality
        function setupTabs() {
            const tabBtns = document.querySelectorAll('.tab-btn');
            const tabPanes = document.querySelectorAll('.tab-pane');
            
            tabBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const targetTab = btn.dataset.tab;
                    
                    tabBtns.forEach(b => b.classList.remove('active'));
                    tabPanes.forEach(p => p.classList.remove('active'));
                    
                    btn.classList.add('active');
                    document.getElementById(`${targetTab}-tab`).classList.add('active');
                });
            });
        }

        // Setup drag and drop
        function setupDragAndDrop() {
            setupDropZoneListeners();
        }

        function setupDropZoneListeners() {
            document.querySelectorAll('.drop-zone').forEach(area => {
                const input = area.querySelector('input[type="file"]');
                const source = area.dataset.source;
                
                // Remove existing listeners to avoid duplicates
                area.replaceWith(area.cloneNode(true));
                area = document.querySelector(`[data-source="${source}"]`);
                
                area.addEventListener('click', () => area.querySelector('input[type="file"]').click());
                
                area.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    area.classList.add('dragover');
                });
                
                area.addEventListener('dragleave', () => {
                    area.classList.remove('dragover');
                });
                
                area.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    area.classList.remove('dragover');
                    
                    console.log('Drop event fired!');
                    
                    try {
                        if (isElectron) {
                            // In Electron, get file paths from dataTransfer
                            const files = [];
                            
                            for (let i = 0; i < e.dataTransfer.files.length; i++) {
                                const file = e.dataTransfer.files[i];
                                files.push({
                                    name: file.name,
                                    path: file.path,
                                    size: file.size
                                });
                            }
                            
                            console.log('Processing', files.length, 'files in Electron mode');
                            await handleElectronFileDrop(files, source);
                        } else {
                            // Browser fallback
                            const files = Array.from(e.dataTransfer.files);
                            console.log('Processing', files.length, 'files in browser mode');
                            await handleFileDrop(files, source);
                        }
                    } catch (error) {
                        console.error('Error in drop handler:', error);
                    }
                });
                
                area.querySelector('input[type="file"]').addEventListener('change', (e) => {
                    handleFileDrop(Array.from(e.target.files), source);
                });
            });
        }
        
        function updateStatus(text) {
            document.getElementById('status-text').textContent = text;
        }

        function showProgress() {
            document.getElementById('progress-container').style.display = 'block';
        }

        function hideProgress() {
            document.getElementById('progress-container').style.display = 'none';
            document.getElementById('progress-fill').style.width = '0%';
            document.getElementById('progress-fill').textContent = '';
            document.getElementById('progress-text').textContent = '';
        }

        function updateProgress(percent, text = '') {
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            progressFill.style.width = `${Math.max(0, Math.min(100, percent))}%`;
            progressFill.textContent = `${Math.round(percent)}%`;
            progressText.textContent = text;
        }

        function setupResizer() {
            const resizeHandle = document.getElementById('resize-handle');
            const analysisContainer = document.getElementById('analysis-container');
            let isResizing = false;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.addEventListener('mousemove', handleResize);
                document.addEventListener('mouseup', stopResize);
                e.preventDefault();
            });

            function handleResize(e) {
                if (!isResizing) return;
                const rect = analysisContainer.getBoundingClientRect();
                const newHeight = window.innerHeight - e.clientY - 100; // 100px buffer for footer
                if (newHeight > 200 && newHeight < window.innerHeight - 300) {
                    analysisContainer.style.height = newHeight + 'px';
                }
            }

            function stopResize() {
                isResizing = false;
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
            }
        }

        function showFileModal(tileId) {
            const tile = sourceTiles.get(tileId);
            if (!tile) return;

            const modal = document.getElementById('fileModal');
            const modalTitle = document.getElementById('modal-title');
            const modalFileList = document.getElementById('modal-file-list');

            modalTitle.textContent = `Files in ${tile.name}`;
            modalFileList.innerHTML = '';

            if (tile.files.length === 0) {
                modalFileList.innerHTML = '<div class="modal-file-item">No files loaded</div>';
            } else {
                tile.files.forEach(fileName => {
                    const fileDiv = document.createElement('div');
                    fileDiv.className = 'modal-file-item';
                    fileDiv.textContent = fileName;
                    modalFileList.appendChild(fileDiv);
                });
            }

            modal.style.display = 'block';
        }

        function closeFileModal() {
            document.getElementById('fileModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.addEventListener('click', (e) => {
            const modal = document.getElementById('fileModal');
            if (e.target === modal) {
                closeFileModal();
            }
        });

        async function handleFileDrop(files, source) {
            if (source === 'create') {
                // Store files temporarily and show input modal
                pendingFiles = files;
                showInputModal('Enter a name for this source tile:', 'Source name...', async (tileName) => {
                    if (tileName && pendingFiles) {
                        try {
                            const tileId = createSourceTile(tileName);
                            await processFiles(pendingFiles, tileId);
                            createNewCreateTile();
                            console.log(`Created tile "${tileName}" with ${pendingFiles.length} files`);
                        } catch (error) {
                            console.error('Error creating tile:', error);
                        }
                    }
                });
            } else {
                // Files dropped on existing tile
                await processFiles(files, source);
            }
        }

        // Electron-specific file drop handler
        async function handleElectronFileDrop(fileInfos, source) {
            console.log('Electron file drop handler called with', fileInfos.length, 'files');
            
            try {
                const processedFiles = [];
                
                // Read file contents using Electron API
                for (const fileInfo of fileInfos) {
                    try {
                        const result = await window.electron.readDroppedFile(fileInfo.path);
                        if (result.success) {
                            processedFiles.push({
                                name: fileInfo.name,
                                path: fileInfo.path,
                                size: fileInfo.size,
                                content: result.data
                            });
                        } else {
                            console.error('Failed to read file:', fileInfo.name, result.error);
                        }
                    } catch (error) {
                        console.error('Error reading file:', fileInfo.name, error);
                    }
                }
                
                console.log('Successfully processed', processedFiles.length, 'files');
                
                // Process the files using our existing logic
                if (source === 'create') {
                    pendingFiles = processedFiles;
                    showInputModal('Enter a name for this source tile:', 'Source name...', async (tileName) => {
                        if (tileName && pendingFiles) {
                            try {
                                const tileId = createSourceTile(tileName);
                                await processElectronFiles(pendingFiles, tileId);
                                createNewCreateTile();
                                console.log(`Created tile "${tileName}" with ${pendingFiles.length} files`);
                            } catch (error) {
                                console.error('Error creating tile:', error);
                            }
                        }
                    });
                } else {
                    // Process for existing tile
                    await processElectronFiles(processedFiles, source);
                }
                
            } catch (error) {
                console.error('Error in handleElectronFileDrop:', error);
            }
        }

        // Updated processFiles function for Electron
        async function processFileData(fileObj, source) {
            console.log('Processing file data:', fileObj.name);
            
            try {
                // Use your existing extraction logic
                const extracted = extractData(fileObj.data, fileObj.name);
                
                // Handle the results based on your source logic
                if (source === 'create') {
                    // Use modal instead of prompt()
                    pendingFiles = [fileObj];
                    showInputModal('Enter a name for this source tile:', 'Source name...', async (tileName) => {
                        if (tileName && pendingFiles) {
                            try {
                                const tileId = createSourceTile(tileName);
                                // Process the extracted data
                                const tile = sourceTiles.get(tileId);
                                if (tile) {
                                    tile.files.push(fileObj.name);
                                    extracted.phones.forEach(phone => tile.phones.add(phone));
                                    extracted.emails.forEach(email => tile.emails.add(email));
                                    extracted.ips.forEach(ip => tile.ips.add(ip));
                                    
                                    // Add row data
                                    extracted.phoneRows.forEach((rows, phone) => {
                                        if (!tile.phoneRows.has(phone)) {
                                            tile.phoneRows.set(phone, []);
                                        }
                                        tile.phoneRows.get(phone).push(...rows);
                                    });
                                    
                                    extracted.emailRows.forEach((rows, email) => {
                                        if (!tile.emailRows.has(email)) {
                                            tile.emailRows.set(email, []);
                                        }
                                        tile.emailRows.get(email).push(...rows);
                                    });
                                    
                                    extracted.ipRows.forEach((rows, ip) => {
                                        if (!tile.ipRows.has(ip)) {
                                            tile.ipRows.set(ip, []);
                                        }
                                        tile.ipRows.get(ip).push(...rows);
                                    });
                                    
                                    updateTileDisplay(tileId);
                                }
                                createNewCreateTile();
                                console.log(`Created tile "${tileName}" and processed ${fileObj.name}`);
                            } catch (error) {
                                console.error('Error creating tile:', error);
                            }
                        }
                    });
                } else {
                    // Process for existing tile
                    const tile = sourceTiles.get(source);
                    if (tile) {
                        tile.files.push(fileObj.name);
                        extracted.phones.forEach(phone => tile.phones.add(phone));
                        extracted.emails.forEach(email => tile.emails.add(email));
                        extracted.ips.forEach(ip => tile.ips.add(ip));
                        
                        // Add row data
                        extracted.phoneRows.forEach((rows, phone) => {
                            if (!tile.phoneRows.has(phone)) {
                                tile.phoneRows.set(phone, []);
                            }
                            tile.phoneRows.get(phone).push(...rows);
                        });
                        
                        extracted.emailRows.forEach((rows, email) => {
                            if (!tile.emailRows.has(email)) {
                                tile.emailRows.set(email, []);
                            }
                            tile.emailRows.get(email).push(...rows);
                        });
                        
                        extracted.ipRows.forEach((rows, ip) => {
                            if (!tile.ipRows.has(ip)) {
                                tile.ipRows.set(ip, []);
                            }
                            tile.ipRows.get(ip).push(...rows);
                        });
                        
                        updateTileDisplay(source);
                    }
                }
                
            } catch (error) {
                console.error('Error processing file data:', error);
            }
        }

        // Process Electron files with proper content handling
        async function processElectronFiles(processedFiles, tileId) {
            const tile = sourceTiles.get(tileId);
            if (!tile) return;
            
            console.log(`Processing ${processedFiles.length} Electron files for tile ${tileId}`);
            
            for (const fileData of processedFiles) {
                try {
                    // Convert buffer to string if needed
                    let text = '';
                    if (typeof fileData.content === 'string') {
                        text = fileData.content;
                    } else if (fileData.content instanceof Buffer) {
                        text = fileData.content.toString('utf8');
                    } else if (fileData.content instanceof Uint8Array) {
                        text = new TextDecoder('utf-8').decode(fileData.content);
                    }
                    
                    console.log(`Processing ${fileData.name}: ${text.length} characters`);
                    
                    // Extract data using existing function
                    const extracted = extractData(text, fileData.name);
                    
                    // Add to tile
                    tile.files.push(fileData.name);
                    
                    // Add extracted data
                    extracted.phones.forEach(phone => tile.phones.add(phone));
                    extracted.emails.forEach(email => tile.emails.add(email));
                    extracted.ips.forEach(ip => tile.ips.add(ip));
                    
                    // Add row data
                    extracted.phoneRows.forEach((rows, phone) => {
                        if (!tile.phoneRows.has(phone)) {
                            tile.phoneRows.set(phone, []);
                        }
                        tile.phoneRows.get(phone).push(...rows);
                    });
                    
                    extracted.emailRows.forEach((rows, email) => {
                        if (!tile.emailRows.has(email)) {
                            tile.emailRows.set(email, []);
                        }
                        tile.emailRows.get(email).push(...rows);
                    });
                    
                    extracted.ipRows.forEach((rows, ip) => {
                        if (!tile.ipRows.has(ip)) {
                            tile.ipRows.set(ip, []);
                        }
                        tile.ipRows.get(ip).push(...rows);
                    });
                    
                } catch (error) {
                    console.error(`Error processing file ${fileData.name}:`, error);
                }
            }
            
            // Update the display
            updateTileDisplay(tileId);
            console.log(`Completed processing ${processedFiles.length} files for tile ${tileId}`);
        }

        function createSourceTile(name) {
            tileCounter++;
            const tileId = `tile-${tileCounter}`;
            
            // Create tile data
            sourceTiles.set(tileId, {
                name: name,
                files: [],
                phones: new Set(),
                emails: new Set(),
                ips: new Set(),
                phoneRows: new Map(), // phone -> array of {fileName, lineNumber, rowData}
                emailRows: new Map(), // email -> array of {fileName, lineNumber, rowData}
                ipRows: new Map()     // ip -> array of {fileName, lineNumber, rowData}
            });
            
            // Replace create tile with actual source tile
            const createTile = document.getElementById('create-source-tile');
            createTile.outerHTML = createSourceTileHTML(tileId, name);
            
            setupDropZoneListeners();
            return tileId;
        }

        function createSourceTileHTML(tileId, name) {
            return `
                <div class="source-tile" id="${tileId}">
                    <div class="tile-header">
                        <div class="tile-title" title="${name}">
                            ${name.length > 15 ? name.substring(0, 15) + '...' : name}
                        </div>
                        <div class="tile-controls">
                            <button class="rename-btn" onclick="downloadTileData('${tileId}')" title="Download all unique data CSV">ðŸ“¥</button>
                            <button class="rename-btn" onclick="renameTile('${tileId}')">Rename</button>
                            <button class="tile-delete-btn" onclick="deleteTile('${tileId}')" title="Delete this tile">âœ–</button>
                        </div>
                    </div>
                    <div class="drop-zone" data-source="${tileId}">
                        <p>Drop files here</p>
                        <input type="file" multiple accept=".csv,.xlsx,.xls,.txt,.html,.pdf">
                    </div>
                    <div class="tile-stats">
                        <span>Files: <span class="file-count-link" onclick="showFileModal('${tileId}')">0</span></span>
                        <span>Unique Numbers: <span class="phone-count">0</span></span>
                        <span>Emails: <span class="email-count">0</span></span>
                        <span>IPs: <span class="ip-count">0</span></span>
                    </div>
                    <div class="file-list"></div>
                </div>
            `;
        }

        function createNewCreateTile() {
            const container = document.getElementById('source-tiles-container');
            const createTileHTML = `
                <div class="source-tile create-tile" id="create-source-tile">
                    <h3>Create Source Tile</h3>
                    <div class="drop-zone" data-source="create">
                        <p>Drag and drop files here or click to browse</p>
                        <input type="file" multiple accept=".csv,.xlsx,.xls,.txt,.html,.pdf">
                    </div>
                </div>
            `;
            container.insertAdjacentHTML('beforeend', createTileHTML);
            setupDropZoneListeners();
        }

        function renameTile(tileId) {
            const tile = sourceTiles.get(tileId);
            if (!tile) return;
            
            showInputModal('Rename Tile', tile.name, (newName) => {
                if (newName && newName !== tile.name) {
                    tile.name = newName;
                    const titleElement = document.querySelector(`#${tileId} .tile-title`);
                    if (titleElement) {
                        const truncatedName = newName.length > 15 ? newName.substring(0, 15) + '...' : newName;
                        titleElement.textContent = truncatedName;
                        titleElement.title = newName;
                    }
                    console.log(`Renamed tile to "${newName}"`);
                }
            });
        }
        
        function normalizePhone(phone) {
            // Clean the phone number of all non-digits
            const digits = phone.replace(/\D/g, '');
            
            // Handle different lengths
            if (digits.length === 11 && digits.startsWith('1')) {
                return digits.substring(1); // Remove leading 1
            } else if (digits.length === 10) {
                return digits;
            } else if (digits.length === 7) {
                // Could be a local number, but we'll skip for now
                return null;
            }
            
            return null; // Invalid phone number
        }

        function isLikelyPhoneNumber(normalizedPhone, context) {
            // Skip numbers that are clearly not phone numbers
            console.log(`Validating phone: ${normalizedPhone}, context: ${context.substring(0, 100)}...`);
            
            // Skip if it's all the same digit (like 0000000000)
            if (/^(\d)\1{9}$/.test(normalizedPhone)) {
                console.log(`Rejected: all same digits`);
                return false;
            }
            
            // Skip if it starts with 0 (invalid area code)
            // Note: Area codes can start with 1 in some cases (like 120, 141, etc.)
            if (normalizedPhone.startsWith('0')) {
                console.log(`Rejected: starts with 0`);
                return false;
            }
            
            // Skip if the context contains decimal points AND the phone number itself contains decimals
            // (Don't reject just because the line has coordinates elsewhere)
            if (normalizedPhone.includes('.')) {
                console.log(`Rejected: phone contains decimal`);
                return false;
            }
            
            // Skip if the phone number appears to be part of a coordinate pair in the context
            if (context.includes('.') && new RegExp(`${normalizedPhone}\\.\\d`).test(context)) {
                console.log(`Rejected: phone appears to be part of coordinate`);
                return false;
            }
            
            // Skip if it looks like a timestamp or other data format
            const contextLower = context.toLowerCase();
            if (contextLower.includes('timestamp') || 
                contextLower.includes('date') || 
                contextLower.includes('time') ||
                contextLower.includes('duration') ||
                contextLower.includes('bytes') ||
                contextLower.includes('size') ||
                contextLower.includes('latitude') ||
                contextLower.includes('longitude') ||
                contextLower.includes('coord') ||
                contextLower.includes('address') ||
                contextLower.includes('street') ||
                contextLower.includes('avenue') ||
                contextLower.includes('lane') ||
                contextLower.includes('road') ||
                contextLower.includes('blvd') ||
                contextLower.includes('drive')) {
                console.log(`Rejected: context contains timestamp/date/address keywords`);
                return false;
            }
            
            // Skip if context contains address indicators (N., S., E., W., followed by street name)
            if (/[NSEW]\.\s+\w+/.test(context)) {
                console.log(`Rejected: context contains address indicators (N/S/E/W)`);
                return false;
            }
            
            // Skip if the phone number itself looks like part of a coordinate pair 
            if (context.includes('-') && new RegExp(`\\-?${normalizedPhone}\\.\\d`).test(context)) {
                console.log(`Rejected: phone looks like part of coordinate pair`);
                return false;
            }
            
            // Accept if it looks like a valid US phone number
            const areaCode = normalizedPhone.substring(0, 3);
            const exchange = normalizedPhone.substring(3, 6);
            
            // Allow more flexible validation for area codes and exchanges
            // Some valid US numbers can have area codes/exchanges starting with 1
            // Only reject if area code starts with 0
            if (areaCode.startsWith('0')) {
                console.log(`Rejected: area code starts with 0`);
                return false;
            }
            
            // Exchange validation - traditionally couldn't start with 0 or 1, but this has changed
            // Only reject if exchange is 000-099 (clearly invalid)
            if (exchange.startsWith('0') && parseInt(exchange) < 100) {
                console.log(`Rejected: exchange is 000-099`);
                return false;
            }
            
            console.log(`âœ… Phone number accepted: ${normalizedPhone}`);
            return true;
        }
        
        function extractDataFromATTFile(text, fileName) {
            console.log('Using specialized AT&T CSV parser');
            const results = { 
                phones: new Set(), 
                emails: new Set(), 
                ips: new Set(),
                phoneRows: new Map(),
                emailRows: new Map(),
                ipRows: new Map()
            };
            
            const lines = text.split('\n');
            console.log(`Processing ${lines.length} lines from AT&T file`);
            
            // Find header line
            let headerIndex = -1;
            let headers = [];
            
            for (let i = 0; i < Math.min(lines.length, 20); i++) {
                const line = lines[i].trim();
                if (line.includes('MSISDN') || line.includes('Originating Number') || line.includes('Dialed Number')) {
                    headerIndex = i;
                    headers = line.split(',').map(h => h.trim());
                    console.log(`Found headers at line ${i}:`, headers);
                    break;
                }
            }
            
            if (headerIndex === -1) {
                console.log('No header found, treating as simple CSV');
                headerIndex = 0;
            }
            
            // Process data lines - optimized for speed
            for (let i = headerIndex + 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line || line.length < 10) continue; // Skip very short lines quickly
                
                const trimmedLine = line.trim();
                if (!trimmedLine) continue;
                
                const columns = trimmedLine.split(',');
                if (columns.length < 3) continue; // Skip malformed lines
                
                // Extract phone numbers from known columns - optimized processing
                for (let colIndex = 0; colIndex < columns.length; colIndex++) {
                    const col = columns[colIndex].trim();
                    // Quick check: must be 10-11 characters and all digits
                    if (col.length >= 10 && col.length <= 11 && /^\d+$/.test(col)) {
                        console.log(`Checking potential phone: ${col} at line ${i}, column ${colIndex}`);
                        const normalized = normalizePhone(col);
                        console.log(`Normalized: ${normalized}`);
                        
                        if (normalized) {
                            const isLikely = isLikelyPhoneNumber(normalized, line);
                            console.log(`isLikelyPhoneNumber result: ${isLikely} for ${normalized}`);
                            
                            if (isLikely) {
                                console.log(`âœ… Found phone number: ${col} -> ${normalized} at line ${i}, column ${colIndex}`);
                                results.phones.add(normalized);
                                
                                if (!results.phoneRows.has(normalized)) {
                                    results.phoneRows.set(normalized, []);
                                }
                                results.phoneRows.get(normalized).push({
                                    fileName: fileName,
                                    lineNumber: i + 1,
                                    rowData: line
                                });
                            } else {
                                console.log(`âŒ Rejected phone number: ${col} -> ${normalized} (failed validation)`);
                            }
                        } else {
                            console.log(`âŒ Failed to normalize: ${col}`);
                        }
                    }
                }
            }
            
            console.log(`AT&T file parsing complete. Found ${results.phones.size} unique phone numbers`);
            return results;
        }

        // ===== SPECIALIZED HTML ANALYSIS SYSTEM =====
        // Based on data science best practices for HTML data extraction
        // This function is completely isolated and doesn't affect other file type processing
        
        function analyzeHTMLDocument(htmlContent, fileName) {
            console.log(`\nðŸ§¬ ===== ADVANCED HTML ANALYSIS: ${fileName} =====`);
            console.log(`ðŸ“Š HTML content length: ${htmlContent.length} characters`);
            
            const results = {
                phones: new Set(),
                emails: new Set(), 
                ips: new Set(),
                phoneRows: new Map(),
                emailRows: new Map(),
                ipRows: new Map()
            };

            // PHASE 1: HTML STRUCTURE ANALYSIS
            console.log(`\nðŸ“‹ PHASE 1: HTML Structure Analysis`);
            
            // Create a temporary DOM element to properly parse HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;
            
            // Extract all text content using multiple strategies
            const extractionStrategies = [
                // Strategy 1: All text nodes (most comprehensive)
                () => {
                    const walker = document.createTreeWalker(
                        tempDiv,
                        NodeFilter.SHOW_TEXT,
                        null,
                        false
                    );
                    const textNodes = [];
                    let node;
                    while (node = walker.nextNode()) {
                        if (node.textContent.trim().length > 0) {
                            textNodes.push({
                                text: node.textContent.trim(),
                                context: node.parentElement ? node.parentElement.tagName : 'unknown'
                            });
                        }
                    }
                    return textNodes;
                },
                
                // Strategy 2: Visible text content
                () => {
                    const allElements = tempDiv.querySelectorAll('*');
                    const textContents = [];
                    allElements.forEach(el => {
                        // Skip script and style elements
                        if (el.tagName === 'SCRIPT' || el.tagName === 'STYLE') return;
                        
                        // Get only direct text content (not nested)
                        for (let child of el.childNodes) {
                            if (child.nodeType === Node.TEXT_NODE && child.textContent.trim()) {
                                textContents.push({
                                    text: child.textContent.trim(),
                                    context: el.tagName,
                                    className: el.className || ''
                                });
                            }
                        }
                    });
                    return textContents;
                },
                
                // Strategy 3: Strip tags and get clean lines
                () => {
                    const cleanText = htmlContent.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
                                                 .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
                                                 .replace(/<[^>]+>/g, ' ')
                                                 .replace(/&nbsp;/g, ' ')
                                                 .replace(/&amp;/g, '&')
                                                 .replace(/&lt;/g, '<')
                                                 .replace(/&gt;/g, '>')
                                                 .replace(/&quot;/g, '"');
                    
                    return cleanText.split('\n').map((line, index) => ({
                        text: line.trim(),
                        context: 'stripped',
                        lineNumber: index + 1
                    })).filter(item => item.text.length > 0);
                }
            ];

            // PHASE 2: MULTI-STRATEGY DATA EXTRACTION
            console.log(`\nðŸ” PHASE 2: Multi-Strategy Data Extraction`);
            
            const allTextData = [];
            
            extractionStrategies.forEach((strategy, strategyIndex) => {
                console.log(`\nðŸ“ˆ Running extraction strategy ${strategyIndex + 1}...`);
                try {
                    const strategyResults = strategy();
                    console.log(`   âœ… Strategy ${strategyIndex + 1} extracted ${strategyResults.length} text segments`);
                    allTextData.push(...strategyResults.map(item => ({
                        ...item,
                        strategy: strategyIndex + 1
                    })));
                } catch (error) {
                    console.log(`   âŒ Strategy ${strategyIndex + 1} failed:`, error.message);
                }
            });

            console.log(`\nðŸ“Š Combined extraction: ${allTextData.length} total text segments`);

            // PHASE 3: PATTERN MATCHING WITH MULTIPLE ALGORITHMS
            console.log(`\nðŸŽ¯ PHASE 3: Advanced Pattern Matching`);
            
            // Phone number patterns optimized for HTML content
            const htmlPhonePatterns = [
                // Exact 10-digit sequences (most common in structured data)
                { 
                    name: 'Exact10Digits',
                    pattern: /\b(\d{10})\b/g,
                    priority: 'high'
                },
                // 11-digit with leading 1
                { 
                    name: 'Exact11Digits', 
                    pattern: /\b(1\d{10})\b/g,
                    priority: 'high'
                },
                // International with plus
                { 
                    name: 'InternationalPlus',
                    pattern: /\+1(\d{10})\b/g,
                    priority: 'high'
                },
                // Formatted patterns
                { 
                    name: 'FormattedDashes',
                    pattern: /\b(\d{3}-\d{3}-\d{4})\b/g,
                    priority: 'medium'
                },
                { 
                    name: 'FormattedParens',
                    pattern: /\((\d{3})\)\s*(\d{3})-?(\d{4})/g,
                    priority: 'medium'
                },
                // Loose patterns for edge cases
                { 
                    name: 'LooseDigits',
                    pattern: /(?:^|[^\d])(\d{3}[\s.-]?\d{3}[\s.-]?\d{4})(?:[^\d]|$)/g,
                    priority: 'low'
                }
            ];

            // Email patterns
            const emailPatterns = [
                {
                    name: 'StandardEmail',
                    pattern: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,
                    priority: 'high'
                }
            ];

            // IP patterns  
            const ipPatterns = [
                {
                    name: 'IPv4',
                    pattern: /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/g,
                    priority: 'high'
                }
            ];

            // Process each text segment
            allTextData.forEach((textData, segmentIndex) => {
                const { text, context, strategy, lineNumber } = textData;
                
                // Skip very short segments unlikely to contain valid data
                if (text.length < 5) return;
                
                // Phone number extraction
                htmlPhonePatterns.forEach(patternInfo => {
                    let match;
                    const regex = new RegExp(patternInfo.pattern.source, patternInfo.pattern.flags);
                    
                    while ((match = regex.exec(text)) !== null) {
                        let phoneCandidate;
                        
                        // Handle different capture group structures
                        if (patternInfo.name === 'FormattedParens') {
                            phoneCandidate = match[1] + match[2] + match[3];
                        } else {
                            phoneCandidate = match[1] || match[0];
                        }
                        
                        // Clean and normalize
                        const cleaned = phoneCandidate.replace(/[\s.-]/g, '');
                        
                        // Validate phone number
                        if (isValidPhoneForHTML(cleaned, text, context)) {
                            const normalized = normalizePhone(cleaned);
                            if (normalized) {
                                console.log(`    ðŸ“ž FOUND PHONE: ${normalized} (${patternInfo.name}) in ${context} - "${text.substring(0, 50)}..."`);
                                results.phones.add(normalized);
                                
                                if (!results.phoneRows.has(normalized)) {
                                    results.phoneRows.set(normalized, []);
                                }
                                results.phoneRows.get(normalized).push({
                                    fileName: fileName,
                                    lineNumber: lineNumber || segmentIndex + 1,
                                    rowData: text,
                                    extractionMethod: `HTML-${patternInfo.name}-Strategy${strategy}`,
                                    context: context
                                });
                            }
                        }
                    }
                });

                // Email extraction
                emailPatterns.forEach(patternInfo => {
                    let match;
                    const regex = new RegExp(patternInfo.pattern.source, patternInfo.pattern.flags);
                    
                    while ((match = regex.exec(text)) !== null) {
                        const email = match[0].toLowerCase();
                        console.log(`    ðŸ“§ FOUND EMAIL: ${email} in ${context}`);
                        results.emails.add(email);
                        
                        if (!results.emailRows.has(email)) {
                            results.emailRows.set(email, []);
                        }
                        results.emailRows.get(email).push({
                            fileName: fileName,
                            lineNumber: lineNumber || segmentIndex + 1,
                            rowData: text,
                            extractionMethod: `HTML-${patternInfo.name}-Strategy${strategy}`,
                            context: context
                        });
                    }
                });

                // IP extraction
                ipPatterns.forEach(patternInfo => {
                    let match;
                    const regex = new RegExp(patternInfo.pattern.source, patternInfo.pattern.flags);
                    
                    while ((match = regex.exec(text)) !== null) {
                        const ip = match[0];
                        console.log(`    ðŸŒ FOUND IP: ${ip} in ${context}`);
                        results.ips.add(ip);
                        
                        if (!results.ipRows.has(ip)) {
                            results.ipRows.set(ip, []);
                        }
                        results.ipRows.get(ip).push({
                            fileName: fileName,
                            lineNumber: lineNumber || segmentIndex + 1,
                            rowData: text,
                            extractionMethod: `HTML-${patternInfo.name}-Strategy${strategy}`,
                            context: context
                        });
                    }
                });
            });

            // PHASE 4: RESULTS VALIDATION AND DEDUPLICATION
            console.log(`\nâœ… PHASE 4: Results Validation`);
            
            // Clean up duplicate phone entries with different formatting
            const cleanedPhones = new Set();
            results.phones.forEach(phone => {
                const clean = phone.replace(/\D/g, '');
                if (clean.length === 10 || (clean.length === 11 && clean.startsWith('1'))) {
                    cleanedPhones.add(clean.length === 10 ? clean : clean.substring(1));
                }
            });
            
            // Update results with cleaned phones
            results.phones.clear();
            cleanedPhones.forEach(phone => results.phones.add(phone));

            console.log(`\nðŸŽ‰ HTML ANALYSIS COMPLETE for ${fileName}:`);
            console.log(`   ðŸ“ž Phones: ${results.phones.size}`);
            console.log(`   ðŸ“§ Emails: ${results.emails.size}`);
            console.log(`   ðŸŒ IPs: ${results.ips.size}`);
            
            if (results.phones.size > 0) {
                console.log(`   ðŸ“ž Phone numbers found:`);
                Array.from(results.phones).slice(0, 10).forEach(phone => {
                    console.log(`      - ${phone}`);
                });
                if (results.phones.size > 10) {
                    console.log(`      ... and ${results.phones.size - 10} more`);
                }
            }

            return results;
        }

        // HTML-specific phone validation (more permissive than CSV validation)
        function isValidPhoneForHTML(phone, textContext, elementContext) {
            // Must be 10 or 11 digits
            if (!/^\d{10,11}$/.test(phone)) return false;
            
            // If 11 digits, must start with 1
            if (phone.length === 11 && !phone.startsWith('1')) return false;
            
            // Skip obvious non-phone patterns
            const badPatterns = [
                /^0{10,11}$/,           // All zeros
                /^1{10,11}$/,           // All ones
                /^(\d)\1{9,10}$/,       // Repeating digit
                /^(123456789|987654321)/, // Sequential
                /^(555|000|999)\d{7}/   // Obviously fake area codes in some contexts
            ];
            
            for (let pattern of badPatterns) {
                if (pattern.test(phone)) return false;
            }
            
            // Context-based validation
            const lowerContext = textContext.toLowerCase();
            
            // Skip if it looks like a timestamp, ID, or other numeric data
            if (lowerContext.includes('timestamp') || 
                lowerContext.includes('id:') ||
                lowerContext.includes('time:') ||
                lowerContext.includes('date:') ||
                lowerContext.includes('version') ||
                lowerContext.includes('size:')) {
                return false;
            }
            
            return true;
        }

        // ===== SPECIALIZED PDF ANALYSIS SYSTEM =====
        // Advanced PDF extraction for social media data exports and forensic documents
        // Completely isolated from other extraction systems
        
        function analyzePDFDocument(pdfText, fileName) {
            console.log(`\nðŸ“„ ===== ADVANCED PDF ANALYSIS: ${fileName} =====`);
            console.log(`ðŸ“Š PDF content length: ${pdfText.length} characters`);
            
            const results = {
                phones: new Set(),
                emails: new Set(), 
                ips: new Set(),
                phoneRows: new Map(),
                emailRows: new Map(),
                ipRows: new Map()
            };

            // PHASE 1: PDF CONTENT ANALYSIS
            console.log(`\nðŸ“‹ PHASE 1: PDF Structure Analysis`);
            
            // Detect PDF type based on content patterns
            const pdfType = detectPDFType(pdfText, fileName);
            console.log(`ðŸ“„ Detected PDF type: ${pdfType}`);
            
            // Split into lines for processing
            const lines = pdfText.split('\n');
            console.log(`ðŸ“„ Processing ${lines.length} lines from PDF`);

            // PHASE 2: SPECIALIZED EXTRACTION PATTERNS
            console.log(`\nðŸ” PHASE 2: Specialized PDF Pattern Extraction`);
            
            // Enhanced patterns for PDF content (social media exports, forensic docs)
            const pdfPatterns = {
                phones: [
                    // International format with plus (+15854020353)
                    /\+1(\d{10})\b/g,
                    // US phone formats
                    /\b(\d{3}[-.\s]?\d{3}[-.\s]?\d{4})\b/g,
                    // Parentheses format
                    /\((\d{3})\)\s*(\d{3})[-.\s]?(\d{4})/g,
                    // Continuous 10-11 digits
                    /\b(\d{10,11})\b/g,
                    // Social media format (no word boundaries)
                    /phone_number:\s*([+]?\d{10,15})/gi,
                    /phone:\s*([+]?\d{10,15})/gi
                ],
                emails: [
                    // Standard email pattern
                    /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,
                    // Social media export format
                    /email_address:\s*([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,})/gi,
                    /email:\s*([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,})/gi
                ],
                ips: [
                    // IPv4 addresses
                    /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/g,
                    // Social media export format
                    /ip:\s*(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/gi,
                    /creation_ip:\s*(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/gi
                ],
                userIds: [
                    // UUIDs and user identifiers
                    /User ID:\s*([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/gi,
                    /\b[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\b/g
                ],
                deviceIds: [
                    // Device identifiers
                    /Device ID[:\s]+([a-f0-9-]{8,})/gi,
                    /GAID[:\s]+([a-f0-9-]{8,})/gi,
                    /SSAID[:\s]+([a-f0-9-]{8,})/gi
                ],
                coordinates: [
                    // GPS coordinates
                    /(-?\d{1,3}\.\d+)\s*[|Â±]\s*(-?\d{1,3}\.\d+)/g,
                    /latitude[:\s]+(-?\d{1,3}\.\d+)/gi,
                    /longitude[:\s]+(-?\d{1,3}\.\d+)/gi
                ]
            };

            // PHASE 3: EXTRACT DATA BY TYPE
            console.log(`\nðŸŽ¯ PHASE 3: Multi-Pattern Data Extraction`);
            
            let extractionCount = {
                phones: 0,
                emails: 0,
                ips: 0,
                userIds: 0,
                deviceIds: 0,
                coordinates: 0
            };

            lines.forEach((line, index) => {
                if (line.trim().length === 0) return;
                
                // Phone number extraction
                pdfPatterns.phones.forEach((pattern, patternIndex) => {
                    let match;
                    const regex = new RegExp(pattern.source, pattern.flags);
                    while ((match = regex.exec(line)) !== null) {
                        let phoneCandidate;
                        
                        // Handle different capture group structures
                        if (patternIndex === 2) { // Parentheses format
                            phoneCandidate = match[1] + match[2] + match[3];
                        } else if (patternIndex === 0) { // Plus format
                            phoneCandidate = '1' + match[1]; // Add back the 1
                        } else {
                            phoneCandidate = match[1] || match[0];
                        }
                        
                        // Clean and validate
                        const cleaned = phoneCandidate.replace(/[^\d]/g, '');
                        if (isValidPDFPhone(cleaned, line)) {
                            const normalized = normalizePhone(cleaned);
                            if (normalized) {
                                console.log(`    ðŸ“ž FOUND PHONE: ${normalized} (Pattern ${patternIndex + 1}) - "${line.trim().substring(0, 80)}..."`);
                                results.phones.add(normalized);
                                extractionCount.phones++;
                                
                                if (!results.phoneRows.has(normalized)) {
                                    results.phoneRows.set(normalized, []);
                                }
                                results.phoneRows.get(normalized).push({
                                    fileName: fileName,
                                    lineNumber: index + 1,
                                    rowData: line.trim(),
                                    extractionMethod: `PDF-Phone-Pattern${patternIndex + 1}`,
                                    context: `PDF-${pdfType}`
                                });
                            }
                        }
                    }
                });

                // Email extraction
                pdfPatterns.emails.forEach((pattern, patternIndex) => {
                    let match;
                    const regex = new RegExp(pattern.source, pattern.flags);
                    while ((match = regex.exec(line)) !== null) {
                        const email = (match[1] || match[0]).toLowerCase();
                        if (isValidEmail(email)) {
                            console.log(`    ðŸ“§ FOUND EMAIL: ${email} - "${line.trim().substring(0, 80)}..."`);
                            results.emails.add(email);
                            extractionCount.emails++;
                            
                            if (!results.emailRows.has(email)) {
                                results.emailRows.set(email, []);
                            }
                            results.emailRows.get(email).push({
                                fileName: fileName,
                                lineNumber: index + 1,
                                rowData: line.trim(),
                                extractionMethod: `PDF-Email-Pattern${patternIndex + 1}`,
                                context: `PDF-${pdfType}`
                            });
                        }
                    }
                });

                // IP address extraction
                pdfPatterns.ips.forEach((pattern, patternIndex) => {
                    let match;
                    const regex = new RegExp(pattern.source, pattern.flags);
                    while ((match = regex.exec(line)) !== null) {
                        const ip = match[1] || match[0];
                        if (isValidIP(ip)) {
                            console.log(`    ðŸŒ FOUND IP: ${ip} - "${line.trim().substring(0, 80)}..."`);
                            results.ips.add(ip);
                            extractionCount.ips++;
                            
                            if (!results.ipRows.has(ip)) {
                                results.ipRows.set(ip, []);
                            }
                            results.ipRows.get(ip).push({
                                fileName: fileName,
                                lineNumber: index + 1,
                                rowData: line.trim(),
                                extractionMethod: `PDF-IP-Pattern${patternIndex + 1}`,
                                context: `PDF-${pdfType}`
                            });
                        }
                    }
                });
            });

            // PHASE 4: RESULTS SUMMARY
            console.log(`\nðŸŽ‰ PDF ANALYSIS COMPLETE for ${fileName}:`);
            console.log(`   ðŸ“ž Phones: ${results.phones.size} (${extractionCount.phones} total matches)`);
            console.log(`   ðŸ“§ Emails: ${results.emails.size} (${extractionCount.emails} total matches)`);
            console.log(`   ðŸŒ IPs: ${results.ips.size} (${extractionCount.ips} total matches)`);
            console.log(`   ðŸ“„ PDF Type: ${pdfType}`);
            
            if (results.phones.size > 0) {
                console.log(`   ðŸ“ž Phone numbers found:`);
                Array.from(results.phones).forEach(phone => {
                    console.log(`      - ${phone}`);
                });
            }
            
            if (results.emails.size > 0) {
                console.log(`   ðŸ“§ Email addresses found:`);
                Array.from(results.emails).forEach(email => {
                    console.log(`      - ${email}`);
                });
            }
            
            if (results.ips.size > 0) {
                console.log(`   ðŸŒ IP addresses found:`);
                Array.from(results.ips).forEach(ip => {
                    console.log(`      - ${ip}`);
                });
            }

            return results;
        }

        function detectPDFType(text, fileName) {
            // Detect type of PDF based on content patterns
            const lowerText = text.toLowerCase();
            const lowerFileName = fileName.toLowerCase();
            
            if (lowerText.includes('snapchat') || lowerText.includes('snap inc')) {
                return 'Snapchat_Export';
            } else if (lowerText.includes('facebook') || lowerText.includes('meta')) {
                return 'Facebook_Export';
            } else if (lowerText.includes('instagram')) {
                return 'Instagram_Export';
            } else if (lowerText.includes('twitter') || lowerText.includes('x.com')) {
                return 'Twitter_Export';
            } else if (lowerText.includes('whatsapp')) {
                return 'WhatsApp_Export';
            } else if (lowerText.includes('telegram')) {
                return 'Telegram_Export';
            } else if (lowerText.includes('user id:') && lowerText.includes('timestamp')) {
                return 'Social_Media_Export';
            } else if (lowerText.includes('forensic') || lowerText.includes('investigation')) {
                return 'Forensic_Report';
            } else {
                return 'General_Document';
            }
        }

        function isValidPDFPhone(phone, context) {
            // Must be 10 or 11 digits
            if (!/^\d{10,11}$/.test(phone)) return false;
            
            // If 11 digits, must start with 1
            if (phone.length === 11 && !phone.startsWith('1')) return false;
            
            // Skip obvious non-phone patterns
            if (/^0{10,11}$/.test(phone)) return false; // All zeros
            if (/^1{10,11}$/.test(phone)) return false; // All ones
            if (/^(\d)\1{9,10}$/.test(phone)) return false; // Repeating digits
            
            // Allow numbers that appear in phone-related context
            const lowerContext = context.toLowerCase();
            if (lowerContext.includes('phone') || 
                lowerContext.includes('number') ||
                lowerContext.includes('contact') ||
                lowerContext.includes('+1') ||
                lowerContext.includes('mobile')) {
                return true;
            }
            
            // For PDFs, be more permissive since context is structured
            return true;
        }

        function isValidEmail(email) {
            // Basic email validation
            const emailRegex = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$/;
            return emailRegex.test(email) && email.length > 5 && email.length < 100;
        }

        function isValidIP(ip) {
            // Validate IPv4 address
            const parts = ip.split('.');
            if (parts.length !== 4) return false;
            
            return parts.every(part => {
                const num = parseInt(part, 10);
                return num >= 0 && num <= 255 && part === String(num);
            });
        }

        
        function extractData(text, fileName) {
            console.log(`\nðŸ” ===== DEEP DIVE EXTRACTION: ${fileName} =====`);
            console.log(`ðŸ“Š Text length: ${text.length} characters`);
            console.log(`ðŸ“ First 200 chars:`, text.substring(0, 200));
            console.log(`ðŸ“ Last 200 chars:`, text.substring(text.length - 200));
            
            // Check if this looks like HTML
            const isHTML = fileName.toLowerCase().endsWith('.html');
            const hasHTMLTags = text.includes('<') && text.includes('>');
            console.log(`ðŸŒ Is HTML file: ${isHTML}`);
            console.log(`ðŸ·ï¸ Contains HTML tags: ${hasHTMLTags}`);
            
            // Route HTML files to specialized HTML analysis system
            if (isHTML || hasHTMLTags) {
                console.log('ðŸ§¬ HTML detected - routing to advanced HTML analysis system');
                return analyzeHTMLDocument(text, fileName);
            }
            
            // Route PDF files to specialized PDF analysis system
            const isPDF = fileName.toLowerCase().endsWith('.pdf');
            if (isPDF) {
                console.log('ðŸ“„ PDF detected - routing to advanced PDF analysis system');
                return analyzePDFDocument(text, fileName);
            }
            
            // Special handling for AT&T tower dump files
            const isATTTowerFile = fileName.toLowerCase().includes('tower') || fileName.toLowerCase().includes('areasearch');
            if (isATTTowerFile) {
                console.log('Detected AT&T tower dump file - using special CSV parsing');
                return extractDataFromATTFile(text, fileName);
            }
            
            const results = { 
                phones: new Set(), 
                emails: new Set(), 
                ips: new Set(),
                phoneRows: new Map(), // phone -> array of row data
                emailRows: new Map(), // email -> array of row data
                ipRows: new Map()     // ip -> array of row data
            };
            
            
            // Extract phone numbers from filename - we'll include these in results but track them to avoid duplicates
            const fileNamePhones = new Set();
            patterns.phone.forEach(pattern => {
                let match;
                const regex = new RegExp(pattern.source, pattern.flags);
                while ((match = regex.exec(fileName)) !== null) {
                    const phoneCandidate = match[1] || match[0];
                    const normalized = normalizePhone(phoneCandidate);
                    if (normalized && isLikelyPhoneNumber(normalized, fileName)) {
                        fileNamePhones.add(normalized);
                        console.log(`âœ… Found phone in filename: ${normalized}`);
                        
                        // Add filename phone numbers to results
                        results.phones.add(normalized);
                        if (!results.phoneRows.has(normalized)) {
                            results.phoneRows.set(normalized, []);
                        }
                        results.phoneRows.get(normalized).push({
                            fileName: fileName,
                            lineNumber: 0, // 0 indicates it came from filename
                            rowData: `From filename: ${fileName}`
                        });
                    }
                }
            });
            
            const lines = text.split('\n');
            console.log(`ðŸ“„ Total lines to process: ${lines.length}`);
            
            // Show sample lines for HTML files
            if (isHTML && lines.length > 0) {
                console.log(`ðŸ“‹ Sample lines from HTML file:`);
                for (let i = 0; i < Math.min(10, lines.length); i++) {
                    if (lines[i].trim().length > 0) {
                        console.log(`  Line ${i + 1}: "${lines[i].substring(0, 100)}${lines[i].length > 100 ? '...' : ''}"`);
                    }
                }
            }
            
            // Check if this might be a CSV file
            const looksLikeCSV = lines.length > 0 && (
                lines[0].includes(',') && 
                (lines[0].split(',').length > 3 || fileName.toLowerCase().endsWith('.csv'))
            );
            
            if (looksLikeCSV) {
                console.log('File appears to be CSV format - using column-aware parsing');
            }
            
            let phoneCount = 0;
            // Show patterns once before processing lines
            console.log(`ðŸ” Starting phone extraction on ${lines.length} lines`);
            console.log(`ðŸ“ž Phone patterns to test: ${patterns.phone.length}`);
            patterns.phone.forEach((pattern, patternIndex) => {
                console.log(`   Pattern ${patternIndex + 1}: ${pattern.source}`);
            });
            
            lines.forEach((line, index) => {
                if (line.trim().length === 0) return; // Skip empty lines
                
                // Show line being processed (only for HTML files for now)
                if (isHTML && line.trim().length > 0) {
                    console.log(`\nðŸ“„ Processing line ${index + 1}: "${line.trim().substring(0, 80)}${line.trim().length > 80 ? '...' : ''}"`);
                }
                
                // For CSV files, also check individual columns
                if (looksLikeCSV && line.includes(',')) {
                    const columns = line.split(',');
                    columns.forEach((col, colIndex) => {
                        const trimmedCol = col.trim();
                        // Check if column contains only digits and is phone-length
                        if (/^\d{10,11}$/.test(trimmedCol)) {
                            const normalized = normalizePhone(trimmedCol);
                            if (normalized && isLikelyPhoneNumber(normalized, line)) {
                                console.log(`CSV column ${colIndex}: found phone ${trimmedCol} -> ${normalized}`);
                                results.phones.add(normalized);
                                phoneCount++;
                                
                                if (!results.phoneRows.has(normalized)) {
                                    results.phoneRows.set(normalized, []);
                                }
                                results.phoneRows.get(normalized).push({
                                    fileName: fileName,
                                    lineNumber: index + 1,
                                    rowData: line
                                });
                            }
                        }
                    });
                }
                
                // Extract phones from each line using patterns
                patterns.phone.forEach((pattern, patternIndex) => {
                    let match;
                    const regex = new RegExp(pattern.source, pattern.flags);
                    let lineMatchCount = 0;
                    while ((match = regex.exec(line)) !== null) {
                        lineMatchCount++;
                        console.log(`    ðŸŽ¯ Pattern ${patternIndex + 1} found match ${lineMatchCount} on line ${index + 1}: "${match[0]}"`);
                        let phoneCandidate;
                        
                        // Handle different pattern types
                        if (patternIndex === 1) { // Parentheses format has multiple capture groups
                            phoneCandidate = match[1] + match[2] + match[3];
                        } else if (patternIndex === 2) { // 11 digit format with 1
                            phoneCandidate = match[1] + match[2] + match[3];
                        } else if (patternIndex === 3) { // Plus format (+1xxxxxxxxxx)
                            phoneCandidate = '1' + match[1]; // Add the 1 back since pattern captures only the 10 digits
                        } else {
                            // For other patterns, use the first capture group or full match
                            phoneCandidate = match[1] || match[0];
                        }
                        
                        console.log(`      ðŸŽ¯ Pattern ${patternIndex} matched: "${match[0]}" -> candidate: "${phoneCandidate}"`);
                        
                        console.log(`      ðŸ”„ Attempting to normalize: "${phoneCandidate}"`);
                        const normalized = normalizePhone(phoneCandidate);
                        console.log(`      ðŸ“± Normalized result: "${normalized}"`);
                        
                        if (normalized) {
                            console.log(`      âœ… Normalization successful, checking validity...`);
                            // Additional validation - skip if it looks like a timestamp or other data
                            const isValid = isLikelyPhoneNumber(normalized, line);
                            console.log(`      ðŸ¤” Validation result: ${isValid}`);
                            if (!isValid) {
                                console.log(`      âŒ Skipping ${normalized} - failed validation. Context: "${line.trim().substring(0, 150)}"`);
                                continue;
                            }
                            
                            // Add to results (even if it was also in filename)
                            results.phones.add(normalized);
                            phoneCount++;
                            
                            if (fileNamePhones.has(normalized)) {
                                console.log(`      âœ… ADDED PHONE: ${normalized} on line ${index + 1} (also found in filename)`);
                            } else {
                                console.log(`      âœ… ADDED PHONE: ${normalized} on line ${index + 1}`);
                            }
                            console.log(`      ðŸ“„ Line context: "${line.trim().substring(0, 100)}${line.trim().length > 100 ? '...' : ''}"`);
                            console.log(`      ðŸ“Š Total phones found so far: ${results.phones.size}`);
                            
                            
                            if (!results.phoneRows.has(normalized)) {
                                results.phoneRows.set(normalized, []);
                            }
                            results.phoneRows.get(normalized).push({
                                fileName: fileName,
                                lineNumber: index + 1,
                                rowData: line.trim()
                            });
                        } else {
                            console.log(`      âŒ NORMALIZATION FAILED for candidate: "${phoneCandidate}"`);
                        }
                    }
                });
                
                // Extract emails
                let match;
                const emailRegex = new RegExp(patterns.email.source, patterns.email.flags);
                while ((match = emailRegex.exec(line)) !== null) {
                    const email = match[0].toLowerCase();
                    results.emails.add(email);
                    if (!results.emailRows.has(email)) {
                        results.emailRows.set(email, []);
                    }
                    results.emailRows.get(email).push({
                        fileName: fileName,
                        lineNumber: index + 1,
                        rowData: line.trim()
                    });
                }
                
                // Extract IPv4 addresses
                const ipv4Regex = new RegExp(patterns.ipv4.source, patterns.ipv4.flags);
                while ((match = ipv4Regex.exec(line)) !== null) {
                    const ip = match[0];
                    results.ips.add(ip);
                    if (!results.ipRows.has(ip)) {
                        results.ipRows.set(ip, []);
                    }
                    results.ipRows.get(ip).push({
                        fileName: fileName,
                        lineNumber: index + 1,
                        rowData: line.trim()
                    });
                }
                
                // Extract IPv6 addresses
                const ipv6Regex = new RegExp(patterns.ipv6.source, patterns.ipv6.flags);
                while ((match = ipv6Regex.exec(line)) !== null) {
                    const ip = match[0];
                    results.ips.add(ip);
                    if (!results.ipRows.has(ip)) {
                        results.ipRows.set(ip, []);
                    }
                    results.ipRows.get(ip).push({
                        fileName: fileName,
                        lineNumber: index + 1,
                        rowData: line.trim()
                    });
                }
            });
            
            console.log(`\nðŸ“‹ ===== EXTRACTION COMPLETE: ${fileName} =====`);
            console.log(`ðŸ“ž Total phones found: ${results.phones.size}`);
            console.log(`ðŸ“§ Total emails found: ${results.emails.size}`);
            console.log(`ðŸŒ Total IPs found: ${results.ips.size}`);
            
            if (results.phones.size > 0) {
                console.log(`ðŸ“ž Phone numbers extracted:`);
                Array.from(results.phones).forEach((phone, index) => {
                    console.log(`   ${index + 1}. ${phone}`);
                });
            } else {
                console.log(`âš ï¸ NO PHONE NUMBERS FOUND - this might indicate an issue!`);
                console.log(`ðŸ” Checking if any phone patterns were tested...`);
            }
            
            console.log(`ðŸ“Š Phone rows map size: ${results.phoneRows.size}`);
            console.log(`ðŸ” ===== END EXTRACTION ANALYSIS =====\n`);
            
            return results;
        }
        
        async function processFiles(files, tileId) {
            const tile = sourceTiles.get(tileId);
            updateStatus(`Processing ${files.length} files for ${tile.name}...`);
            
            for (const file of files) {
                try {
                    // Show specific message for PDF files
                    if (file.name.toLowerCase().endsWith('.pdf')) {
                        updateStatus(`ðŸ“„ Extracting text from PDF: ${file.name}...`);
                        console.log(`ðŸ“„ Starting PDF processing for: ${file.name}`);
                    } else {
                        updateStatus(`Processing ${file.name}...`);
                    }
                    
                    const text = await readFileAsText(file);
                    const extracted = extractData(text, file.name);
                    
                    // Store in tile data
                    tile.files.push(file.name);
                    
                    extracted.phones.forEach(phone => tile.phones.add(phone));
                    extracted.emails.forEach(email => tile.emails.add(email));
                    extracted.ips.forEach(ip => tile.ips.add(ip));
                    
                    // Merge phone row data
                    console.log(`Merging phone data for file ${file.name} into tile ${tile.name}`);
                    extracted.phoneRows.forEach((rows, phone) => {
                        console.log(`  Phone ${phone}: ${rows.length} rows to merge`);
                        if (!tile.phoneRows.has(phone)) {
                            tile.phoneRows.set(phone, []);
                        }
                        const beforeCount = tile.phoneRows.get(phone).length;
                        tile.phoneRows.get(phone).push(...rows);
                        const afterCount = tile.phoneRows.get(phone).length;
                        console.log(`    Before: ${beforeCount} rows, After: ${afterCount} rows`);
                    });
                    
                    // Merge email row data
                    extracted.emailRows.forEach((rows, email) => {
                        if (!tile.emailRows.has(email)) {
                            tile.emailRows.set(email, []);
                        }
                        tile.emailRows.get(email).push(...rows);
                    });
                    
                    // Merge IP row data
                    extracted.ipRows.forEach((rows, ip) => {
                        if (!tile.ipRows.has(ip)) {
                            tile.ipRows.set(ip, []);
                        }
                        tile.ipRows.get(ip).push(...rows);
                    });
                    
                    // Update file display
                    const fileDiv = document.createElement('div');
                    fileDiv.className = 'file-list-item';
                    fileDiv.innerHTML = `
                        <span>${file.name}</span>
                        <button class="file-remove-btn" onclick="removeFile('${tileId}', '${file.name}')" title="Remove this file">âœ–</button>
                    `;
                    document.querySelector(`#${tileId} .file-list`).appendChild(fileDiv);
                    
                    // Update stats counters
                    const tileElement = document.getElementById(tileId);
                    const fileCount = tileElement.querySelector('.file-count-link');
                    const phoneCount = tileElement.querySelector('.phone-count');
                    const emailCount = tileElement.querySelector('.email-count');
                    const ipCount = tileElement.querySelector('.ip-count');
                    fileCount.textContent = tile.files.length;
                    phoneCount.textContent = tile.phones.size;
                    emailCount.textContent = tile.emails.size;
                    ipCount.textContent = tile.ips.size;
                    
                } catch (error) {
                    console.error('Error processing file:', file.name, error);
                    updateStatus(`Error processing ${file.name}`);
                }
            }
            
            updateAllAnalysis();
            updateStatus('Files processed successfully');
        }
        
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                // Check file type
                const fileName = file.name.toLowerCase();
                const isExcel = fileName.endsWith('.xlsx') || fileName.endsWith('.xls');
                const isPDF = fileName.endsWith('.pdf');
                
                if (isExcel && typeof XLSX !== 'undefined') {
                    // Use XLSX library for Excel files
                    reader.onload = (e) => {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            
                            console.log(`Processing Excel file with ${workbook.SheetNames.length} sheets:`, workbook.SheetNames);
                            
                            let allText = '';
                            
                            // Process all worksheets
                            workbook.SheetNames.forEach(sheetName => {
                                console.log(`Processing sheet: ${sheetName}`);
                                const worksheet = workbook.Sheets[sheetName];
                                
                                // Get the range of the worksheet
                                const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1:A1');
                                console.log(`Sheet range: ${range.s.r}-${range.e.r} rows, ${range.s.c}-${range.e.c} cols`);
                                
                                // Convert to JSON with all cells as strings to preserve phone numbers
                                const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
                                    header: 1, 
                                    defval: '',
                                    raw: false // This ensures numbers are treated as strings
                                });
                                
                                console.log(`Extracted ${jsonData.length} rows from sheet ${sheetName}`);
                                
                                // Process each row - preserve full row structure
                                jsonData.forEach((row, rowIndex) => {
                                    if (Array.isArray(row) && row.length > 0) {
                                        // Join all cells in the row with tabs to preserve row structure
                                        const rowText = row.map(cell => {
                                            if (cell === null || cell === undefined) return '';
                                            return String(cell).trim();
                                        }).join('\t');
                                        
                                        // Add the full row as a single line
                                        if (rowText.trim().length > 0) {
                                            allText += rowText + '\n';
                                        }
                                    }
                                });
                            });
                            
                            console.log(`Excel parsing complete. Total text length: ${allText.length}`);
                            resolve(allText);
                        } catch (error) {
                            console.error('Excel parsing failed:', error);
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                } else if (isPDF) {
                    // For PDF files, use PDF.js for automatic text extraction
                    console.log(`ðŸ“„ PDF file detected: ${fileName} - using PDF.js for automatic extraction`);
                    
                    reader.onload = async (e) => {
                        try {
                            const arrayBuffer = e.target.result;
                            console.log(`ðŸ“„ PDF loaded: ${arrayBuffer.byteLength} bytes`);
                            
                            // Use PDF.js to extract text automatically
                            const extractedText = await extractTextFromPDFUsingPDFJS(arrayBuffer, fileName);
                            
                            if (extractedText && extractedText.length > 50) {
                                console.log(`âœ… PDF.js extraction successful: ${extractedText.length} characters`);
                                console.log(`ðŸ“„ Sample extracted text: "${extractedText.substring(0, 200)}..."`);
                                resolve(extractedText);
                            } else {
                                console.log(`âš ï¸ PDF.js extraction yielded limited results, trying fallback method`);
                                // Fallback to basic extraction
                                const fallbackText = extractTextFromPDFContent(arrayBuffer, fileName);
                                resolve(fallbackText || 'PDF processing failed - please convert to text file');
                            }
                        } catch (error) {
                            console.error('PDF.js processing failed:', error);
                            console.log(`âš ï¸ Falling back to basic PDF extraction`);
                            
                            try {
                                // Fallback to basic extraction
                                const fallbackText = extractTextFromPDFContent(e.target.result, fileName);
                                resolve(fallbackText || 'PDF processing failed - please convert to text file');
                            } catch (fallbackError) {
                                console.error('Fallback PDF extraction also failed:', fallbackError);
                                resolve('PDF processing failed - please convert to text file and upload .txt instead');
                            }
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file); // Read as ArrayBuffer for PDF.js
                } else {
                    // For text files, HTML, CSV, or when XLSX library isn't available
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file, 'UTF-8');
                }
            });
        }
        
        // ===== PDF.js AUTOMATIC TEXT EXTRACTION =====
        // Professional PDF text extraction using Mozilla's PDF.js library
        
        async function extractTextFromPDFUsingPDFJS(arrayBuffer, fileName) {
            console.log(`\nðŸ”§ ===== PDF.js EXTRACTION: ${fileName} =====`);
            
            try {
                // Check if PDF.js is available
                if (typeof pdfjsLib === 'undefined') {
                    throw new Error('PDF.js library not loaded');
                }
                
                console.log(`ðŸ“š PDF.js library version: ${pdfjsLib.version || 'unknown'}`);
                
                // Load the PDF document
                const typedArray = new Uint8Array(arrayBuffer);
                console.log(`ðŸ“„ Loading PDF document (${typedArray.length} bytes)...`);
                
                const pdf = await pdfjsLib.getDocument({
                    data: typedArray,
                    verbosity: 0 // Reduce console noise
                }).promise;
                
                console.log(`ðŸ“„ PDF loaded successfully: ${pdf.numPages} pages`);
                
                let fullText = '';
                let totalTextItems = 0;
                
                // Extract text from each page
                for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                    console.log(`ðŸ“„ Processing page ${pageNum}/${pdf.numPages}...`);
                    
                    try {
                        const page = await pdf.getPage(pageNum);
                        const textContent = await page.getTextContent();
                        
                        // Combine all text items from the page
                        const pageText = textContent.items
                            .filter(item => item.str && item.str.trim().length > 0)
                            .map(item => item.str.trim())
                            .join(' ');
                        
                        if (pageText.length > 0) {
                            fullText += pageText + '\n';
                            totalTextItems += textContent.items.length;
                            console.log(`   âœ… Page ${pageNum}: extracted ${textContent.items.length} text items (${pageText.length} chars)`);
                        } else {
                            console.log(`   âš ï¸ Page ${pageNum}: no text content found`);
                        }
                        
                        // Show sample of first page
                        if (pageNum === 1 && pageText.length > 0) {
                            console.log(`   ðŸ“‹ Page 1 sample: "${pageText.substring(0, 150)}..."`);
                        }
                        
                    } catch (pageError) {
                        console.error(`âŒ Error processing page ${pageNum}:`, pageError);
                        continue; // Continue with next page
                    }
                }
                
                // Clean up the extracted text
                const cleanedText = cleanPDFText(fullText);
                
                console.log(`\nðŸŽ‰ PDF.js extraction complete:`);
                console.log(`   ðŸ“„ Pages processed: ${pdf.numPages}`);
                console.log(`   ðŸ“ Total text items: ${totalTextItems}`);
                console.log(`   ðŸ“Š Raw text length: ${fullText.length} characters`);
                console.log(`   âœ¨ Cleaned text length: ${cleanedText.length} characters`);
                
                if (cleanedText.length > 0) {
                    console.log(`   ðŸ“‹ Final text preview: "${cleanedText.substring(0, 200)}..."`);
                    
                    // Check if we found expected patterns
                    const phoneMatches = cleanedText.match(/(\+?\d{10,15}|\d{3}[-.\s]?\d{3}[-.\s]?\d{4})/g);
                    const emailMatches = cleanedText.match(/[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}/g);
                    const ipMatches = cleanedText.match(/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/g);
                    
                    console.log(`   ðŸ“ž Phone patterns found: ${phoneMatches ? phoneMatches.length : 0}`);
                    console.log(`   ðŸ“§ Email patterns found: ${emailMatches ? emailMatches.length : 0}`);
                    console.log(`   ðŸŒ IP patterns found: ${ipMatches ? ipMatches.length : 0}`);
                    
                    if (phoneMatches && phoneMatches.length > 0) {
                        console.log(`   ðŸ“ž Sample phones: ${phoneMatches.slice(0, 3).join(', ')}`);
                    }
                }
                
                return cleanedText;
                
            } catch (error) {
                console.error(`âŒ PDF.js extraction failed for ${fileName}:`, error);
                throw error;
            }
        }
        
        function cleanPDFText(rawText) {
            if (!rawText) return '';
            
            // Clean up the extracted text
            let cleaned = rawText
                // Normalize whitespace
                .replace(/\s+/g, ' ')
                // Remove excessive line breaks
                .replace(/\n\s*\n\s*\n/g, '\n\n')
                // Clean up common PDF artifacts
                .replace(/\ufeff/g, '') // BOM
                .replace(/\u00a0/g, ' ') // Non-breaking space
                .replace(/\u2019/g, "'") // Smart quote
                .replace(/\u201c|\u201d/g, '"') // Smart quotes
                // Preserve line structure for better parsing
                .replace(/([.!?])\s+/g, '$1\n')
                .replace(/:\s+/g, ': ')
                .trim();
            
            return cleaned;
        }
        
        function extractTextFromPDFContent(rawContent, fileName) {
            console.log(`\nðŸ“„ ===== PDF TEXT EXTRACTION: ${fileName} =====`);
            
            try {
                // Method 1: Look for text streams between 'stream' and 'endstream'
                const streamRegex = /stream\s*([\s\S]*?)\s*endstream/g;
                let extractedText = '';
                let match;
                
                while ((match = streamRegex.exec(rawContent)) !== null) {
                    const streamContent = match[1];
                    // Try to extract readable text from stream
                    const readableText = extractReadableText(streamContent);
                    if (readableText.length > 0) {
                        extractedText += readableText + '\n';
                    }
                }
                
                // Method 2: Look for direct text content (for some PDFs)
                const textRegex = /\((.*?)\)/g;
                const directTextMatches = [];
                while ((match = textRegex.exec(rawContent)) !== null) {
                    const text = match[1];
                    if (text.length > 3 && /[a-zA-Z0-9@+.]/.test(text)) {
                        directTextMatches.push(text);
                    }
                }
                
                if (directTextMatches.length > 0) {
                    extractedText += directTextMatches.join(' ') + '\n';
                }
                
                // Method 3: Look for specific patterns we care about
                const patterns = [
                    /phone_number[:\s]*([+]?\d{10,15})/gi,
                    /email_address[:\s]*([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,})/gi,
                    /ip[:\s]*(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/gi,
                    /\+1\d{10}/g,
                    /\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/g,
                    /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,
                    /\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g
                ];
                
                patterns.forEach(pattern => {
                    const matches = rawContent.match(pattern);
                    if (matches) {
                        extractedText += matches.join('\n') + '\n';
                    }
                });
                
                console.log(`ðŸ“„ Extracted text preview: "${extractedText.substring(0, 200)}..."`);
                return extractedText;
                
            } catch (error) {
                console.error('PDF text extraction error:', error);
                return rawContent; // Fallback to raw content
            }
        }
        
        function extractReadableText(streamContent) {
            // Basic text extraction from PDF streams
            // This is a simplified approach - real PDF parsing is much more complex
            try {
                // Remove non-printable characters and try to find readable text
                let text = streamContent.replace(/[^\x20-\x7E\n\r]/g, ' ');
                
                // Look for patterns that might be text
                const lines = text.split(/[\n\r]+/);
                const readableLines = lines.filter(line => {
                    const trimmed = line.trim();
                    // Keep lines that have reasonable text characteristics
                    return trimmed.length > 2 && 
                           /[a-zA-Z0-9@+.]/.test(trimmed) &&
                           trimmed.length < 200; // Avoid binary garbage
                });
                
                return readableLines.join('\n');
            } catch (error) {
                console.error('Stream text extraction error:', error);
                return '';
            }
        }
        
        function updatePhoneAnalysis() {
            console.log('=== UPDATE PHONE ANALYSIS ===');
            // Only show common phones across multiple tiles
            const phoneMap = new Map(); // phone -> {tiles: Set<tileName>}
            
            // Collect all phones from all tiles
            console.log(`Total tiles: ${sourceTiles.size}`);
            sourceTiles.forEach((tile, tileId) => {
                console.log(`Processing tile ${tileId} (${tile.name}): ${tile.phones.size} phones`);
                tile.phones.forEach(phone => {
                    if (!phoneMap.has(phone)) {
                        phoneMap.set(phone, { tiles: new Set() });
                    }
                    phoneMap.get(phone).tiles.add(tile.name);
                });
            });
            
            console.log(`Total unique phones across all tiles: ${phoneMap.size}`);
            
            // Filter to only show phones that appear in multiple tiles
            const commonPhones = new Map();
            phoneMap.forEach((data, phone) => {
                if (data.tiles.size > 1) { // Appears in more than one unique tile
                    console.log(`Common phone ${phone} found in ${data.tiles.size} tiles: ${Array.from(data.tiles).join(', ')}`);
                    commonPhones.set(phone, { 
                        count: data.tiles.size, 
                        tiles: Array.from(data.tiles) 
                    });
                }
            });
            
            console.log(`Total common phones: ${commonPhones.size}`);
            displayPhoneResults(commonPhones);
        }

        function updateEmailAnalysis() {
            // Only show common emails across multiple tiles
            const emailMap = new Map(); // email -> {tiles: Set<tileName>}
            
            // Collect all emails from all tiles
            sourceTiles.forEach((tile, tileId) => {
                tile.emails.forEach(email => {
                    if (!emailMap.has(email)) {
                        emailMap.set(email, { tiles: new Set() });
                    }
                    emailMap.get(email).tiles.add(tile.name);
                });
            });
            
            // Filter to only show emails that appear in multiple tiles
            const commonEmails = new Map();
            emailMap.forEach((data, email) => {
                if (data.tiles.size > 1) { // Appears in more than one unique tile
                    commonEmails.set(email, { 
                        count: data.tiles.size, 
                        tiles: Array.from(data.tiles) 
                    });
                }
            });
            
            displayEmailResults(commonEmails);
        }

        function updateIPAnalysis() {
            // Only show common IPs across multiple tiles
            const ipMap = new Map(); // ip -> {tiles: Set<tileName>}
            
            // Collect all IPs from all tiles
            sourceTiles.forEach((tile, tileId) => {
                tile.ips.forEach(ip => {
                    if (!ipMap.has(ip)) {
                        ipMap.set(ip, { tiles: new Set() });
                    }
                    ipMap.get(ip).tiles.add(tile.name);
                });
            });
            
            // Filter to only show IPs that appear in multiple tiles
            const commonIPs = new Map();
            ipMap.forEach((data, ip) => {
                if (data.tiles.size > 1) { // Appears in more than one unique tile
                    commonIPs.set(ip, { 
                        count: data.tiles.size, 
                        tiles: Array.from(data.tiles) 
                    });
                }
            });
            
            displayIPResults(commonIPs);
        }

        function updateAllAnalysis() {
            updatePhoneAnalysis();
            updateEmailAnalysis();
            updateIPAnalysis();
        }
        
        function displayPhoneResults(phoneMap) {
            const container = document.getElementById('phones-results');
            container.innerHTML = '';
            
            if (phoneMap.size === 0) {
                container.innerHTML = '<div class="result-item"><span>No common phone numbers found across sources</span><span></span><span></span></div>';
                return;
            }
            
            Array.from(phoneMap.entries())
                .sort((a, b) => b[1].count - a[1].count)
                .forEach(([phone, info]) => {
                    const div = document.createElement('div');
                    div.className = 'result-item clickable-phone';
                    div.innerHTML = `
                        <span class="phone-number" onclick="showPhoneSearchModal('${phone}')" style="cursor: pointer; color: var(--accent);">${phone}</span>
                        <span>${info.tiles.join(', ')}</span>
                        <span>Found in ${info.count} sources</span>
                    `;
                    container.appendChild(div);
                });
        }

        function displayEmailResults(emailMap) {
            const container = document.getElementById('emails-results');
            container.innerHTML = '';
            
            if (emailMap.size === 0) {
                container.innerHTML = '<div class="result-item"><span>No common email addresses found across sources</span><span></span><span></span></div>';
                return;
            }
            
            Array.from(emailMap.entries())
                .sort((a, b) => b[1].count - a[1].count)
                .forEach(([email, info]) => {
                    const div = document.createElement('div');
                    div.className = 'result-item';
                    div.innerHTML = `
                        <span class="email-address" onclick="showEmailSearchModal('${email}')" style="cursor: pointer; color: var(--accent);">${email}</span>
                        <span>${info.tiles.join(', ')}</span>
                        <span>Found in ${info.count} sources</span>
                    `;
                    container.appendChild(div);
                });
        }

        function displayIPResults(ipMap) {
            const container = document.getElementById('ips-results');
            container.innerHTML = '';
            
            if (ipMap.size === 0) {
                container.innerHTML = '<div class="result-item"><span>No common IP addresses found across sources</span><span></span><span></span></div>';
                return;
            }
            
            Array.from(ipMap.entries())
                .sort((a, b) => b[1].count - a[1].count)
                .forEach(([ip, info]) => {
                    const div = document.createElement('div');
                    div.className = 'result-item';
                    div.innerHTML = `
                        <span class="ip-address" onclick="showIPSearchModal('${ip}')" style="cursor: pointer; color: var(--accent);">${ip}</span>
                        <span>${info.tiles.join(', ')}</span>
                        <span>Found in ${info.count} sources</span>
                    `;
                    container.appendChild(div);
                });
        }

        function displayResults(containerId, dataMap) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            Array.from(dataMap.entries())
                .sort((a, b) => b[1].count - a[1].count)
                .forEach(([value, info]) => {
                    const div = document.createElement('div');
                    div.className = 'result-item';
                    div.innerHTML = `
                        <span>${value}</span>
                        <span>${info.sources.join(', ')}</span>
                        <span>Count: ${info.count}</span>
                    `;
                    container.appendChild(div);
                });
        }
        
        function parseRowData(rowData, fileName) {
            // Try to intelligently parse structured data formats
            const result = { headers: [], data: {} };
            
            try {
                // Check if this looks like CSV data (contains commas)
                if (rowData.includes(',')) {
                    const columns = rowData.split(',').map(col => col.trim());
                    
                    // Try to identify if this is AT&T tower data
                    if (fileName.toLowerCase().includes('tower') || fileName.toLowerCase().includes('areasearch')) {
                        // Known AT&T tower dump format
                        const attHeaders = [
                            'Item', 'Connection Date', 'Connection Time', 'MSISDN', 'IMSI', 
                            'Latitude', 'Longitude', 'ECGI', 'Cell Latitude', 'Cell Longitude',
                            'Sector Orientation', 'Timing Advance', 'Location Method', 'Location Accuracy'
                        ];
                        
                        // For area search files
                        if (fileName.toLowerCase().includes('areasearch') && columns.length >= 13) {
                            result.headers = attHeaders.slice(0, columns.length);
                            columns.forEach((value, index) => {
                                if (index < result.headers.length) {
                                    result.data[result.headers[index]] = value;
                                }
                            });
                        }
                        // For tower files - different format
                        else if (fileName.toLowerCase().includes('tower') && columns.length >= 15) {
                            const towerHeaders = [
                                'Source', 'Connection Date', 'Connection Time (UTC)', 'Disconnection Date', 
                                'Disconnection Time (UTC)', 'Originating Number', 'Dialed Number', 
                                'Terminating Number', 'Call Type', 'Number Associated w/Tower', 
                                'IMSI Associated w/Tower', 'IMEI Associated w/Tower', 'Minutes', 
                                'Tower LAC/CID or ECGI', 'APN', 'Type'
                            ];
                            result.headers = towerHeaders.slice(0, columns.length);
                            columns.forEach((value, index) => {
                                if (index < result.headers.length) {
                                    result.data[result.headers[index]] = value;
                                }
                            });
                        }
                    }
                    // Generic CSV parsing - try to detect common headers
                    else if (columns.length >= 3) {
                        // Create generic column names
                        for (let i = 0; i < columns.length; i++) {
                            const header = `Column_${i + 1}`;
                            result.headers.push(header);
                            result.data[header] = columns[i];
                        }
                    }
                }
            } catch (error) {
                console.log('Error parsing row data:', error);
            }
            
            return result;
        }

        function exportPhoneRows(phone) {
            console.log(`Exporting all occurrences of phone number: ${phone}`);
            
            // Collect ALL rows containing this phone number from ALL tiles
            const allRows = [];
            
            // Search through ALL tiles
            sourceTiles.forEach((tile, tileId) => {
                if (tile.phoneRows.has(phone)) {
                    const rows = tile.phoneRows.get(phone);
                    console.log(`Found ${rows.length} occurrences in ${tile.name}`);
                    
                    rows.forEach(row => {
                        // Debug: Log the first few rows to verify content
                        if (allRows.length < 3) {
                            console.log(`Row ${allRows.length + 1} data:`, {
                                fileName: row.fileName,
                                line: row.lineNumber,
                                dataPreview: row.rowData.substring(0, 100) + '...'
                            });
                        }
                        allRows.push({
                            tile: tile.name,
                            fileName: row.fileName,
                            lineNumber: row.lineNumber,
                            rowData: row.rowData
                        });
                    });
                }
            });
            
            console.log(`Total occurrences found: ${allRows.length}`);
            
            if (allRows.length === 0) {
                alert('No rows found for this phone number');
                return;
            }
            
            // Create CSV with original row data
            const headers = ['Source Tile', 'File Name', 'Line Number', 'Phone Number', 'Original Row Data'];
            const csvContent = [headers, ...allRows.map(row => [
                row.tile,
                row.fileName,
                row.lineNumber,
                phone,
                row.rowData
            ])];
            
            const filename = `phone_${phone}_all_occurrences_${new Date().toISOString().split('T')[0]}.csv`;
            
            // Convert to CSV string
            const csvString = csvContent
                .map(row => row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(','))
                .join('\n');
            
            // Download CSV
            const blob = new Blob([csvString], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);
            
            const uniqueTiles = [...new Set(allRows.map(row => row.tile))];
            updateStatus(`Exported ${allRows.length} rows containing phone ${phone} from ${uniqueTiles.length} source(s): ${uniqueTiles.join(', ')}`);
        }

        function exportEmailRows(email) {
            console.log(`Exporting all occurrences of email: ${email}`);
            
            // Collect all rows containing this email from all tiles
            const allRows = [];
            
            sourceTiles.forEach((tile, tileId) => {
                if (tile.emailRows.has(email)) {
                    const rows = tile.emailRows.get(email);
                    console.log(`Found ${rows.length} occurrences in ${tile.name}`);
                    
                    rows.forEach(row => {
                        // Debug: Log the first few rows to verify content
                        if (allRows.length < 3) {
                            console.log(`Row ${allRows.length + 1} data:`, {
                                fileName: row.fileName,
                                line: row.lineNumber,
                                dataPreview: row.rowData.substring(0, 100) + '...'
                            });
                        }
                        allRows.push({
                            tile: tile.name,
                            fileName: row.fileName,
                            lineNumber: row.lineNumber,
                            rowData: row.rowData
                        });
                    });
                }
            });
            
            console.log(`Total occurrences found: ${allRows.length}`);
            
            if (allRows.length === 0) {
                alert('No rows found for this email address');
                return;
            }
            
            // Create CSV with original row data
            const headers = ['Source Tile', 'File Name', 'Line Number', 'Email Address', 'Original Row Data'];
            const csvContent = [headers, ...allRows.map(row => [
                row.tile,
                row.fileName,
                row.lineNumber,
                email,
                row.rowData
            ])];
            
            const filename = `email_${email.replace(/[@.]/g, '_')}_all_occurrences_${new Date().toISOString().split('T')[0]}.csv`;
            
            // Convert to CSV string
            const csvString = csvContent
                .map(row => row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(','))
                .join('\n');
            
            // Download CSV
            const blob = new Blob([csvString], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);
            
            const uniqueTiles = [...new Set(allRows.map(row => row.tile))];
            updateStatus(`Exported ${allRows.length} rows containing email ${email} from ${uniqueTiles.length} source(s)`);
        }

        function exportIPRows(ip) {
            console.log(`Exporting all occurrences of IP: ${ip}`);
            
            // Collect all rows containing this IP from all tiles
            const allRows = [];
            
            sourceTiles.forEach((tile, tileId) => {
                if (tile.ipRows.has(ip)) {
                    const rows = tile.ipRows.get(ip);
                    console.log(`Found ${rows.length} occurrences in ${tile.name}`);
                    
                    rows.forEach(row => {
                        // Debug: Log the first few rows to verify content
                        if (allRows.length < 3) {
                            console.log(`Row ${allRows.length + 1} data:`, {
                                fileName: row.fileName,
                                line: row.lineNumber,
                                dataPreview: row.rowData.substring(0, 100) + '...'
                            });
                        }
                        allRows.push({
                            tile: tile.name,
                            fileName: row.fileName,
                            lineNumber: row.lineNumber,
                            rowData: row.rowData
                        });
                    });
                }
            });
            
            console.log(`Total occurrences found: ${allRows.length}`);
            
            if (allRows.length === 0) {
                alert('No rows found for this IP address');
                return;
            }
            
            // Create CSV with original row data
            const headers = ['Source Tile', 'File Name', 'Line Number', 'IP Address', 'Original Row Data'];
            const csvContent = [headers, ...allRows.map(row => [
                row.tile,
                row.fileName,
                row.lineNumber,
                ip,
                row.rowData
            ])];
            
            const filename = `ip_${ip.replace(/\./g, '_')}_all_occurrences_${new Date().toISOString().split('T')[0]}.csv`;
            
            // Convert to CSV string
            const csvString = csvContent
                .map(row => row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(','))
                .join('\n');
            
            // Download CSV
            const blob = new Blob([csvString], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);
            
            const uniqueTiles = [...new Set(allRows.map(row => row.tile))];
            updateStatus(`Exported ${allRows.length} rows containing IP ${ip} from ${uniqueTiles.length} source(s)`);
        }

        function downloadTileData(tileId) {
            const tile = sourceTiles.get(tileId);
            if (!tile) {
                alert('Tile not found');
                return;
            }
            
            // Check if there's any data to export
            if (tile.phones.size === 0 && tile.emails.size === 0 && tile.ips.size === 0) {
                alert('No data found in this tile');
                return;
            }
            
            // Prepare data arrays
            const phoneArray = Array.from(tile.phones);
            const emailArray = Array.from(tile.emails);
            const ipArray = Array.from(tile.ips);
            
            // Find the maximum length to ensure all rows align
            const maxLength = Math.max(phoneArray.length, emailArray.length, ipArray.length);
            
            // Create CSV content with all data types
            const headers = ['Phone Numbers', 'Email Addresses', 'IP Addresses'];
            const rows = [];
            
            for (let i = 0; i < maxLength; i++) {
                rows.push([
                    phoneArray[i] || '',
                    emailArray[i] || '',
                    ipArray[i] || ''
                ]);
            }
            
            const csvContent = [headers, ...rows]
                .map(row => row.map(field => `"${field}"`).join(','))
                .join('\n');
            
            // Download CSV
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${tile.name}-all-data-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
            
            // Update status with counts
            const counts = [];
            if (phoneArray.length > 0) counts.push(`${phoneArray.length} phone numbers`);
            if (emailArray.length > 0) counts.push(`${emailArray.length} email addresses`);
            if (ipArray.length > 0) counts.push(`${ipArray.length} IP addresses`);
            
            updateStatus(`Exported ${counts.join(', ')} from ${tile.name}`);
        }

        function analyzeCommon() {
            updateAllAnalysis(); // Update all analysis
            updateStatus('Analysis updated');
        }

        async function saveDatabase() {
            if (sourceTiles.size === 0) {
                alert('No data to save');
                return;
            }
            
            // Check if File System Access API is supported
            if ('showSaveFilePicker' in window) {
                try {
                    // Use File System Access API for better file explorer experience
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: `CAST_Database_${new Date().toISOString().replace(/[:.]/g, '-').split('T')[0]}_${new Date().toTimeString().split(' ')[0].replace(/:/g, '')}.db`,
                        types: [{
                            description: 'CAST Database files',
                            accept: { 'application/json': ['.db'] }
                        }]
                    });
                    
                    // Convert sourceTiles to enhanced format with metadata preservation
                    const saveData = {
                        version: "2.0", // Enhanced version
                        format: "CAST_JSON",
                        timestamp: new Date().toISOString(),
                        tileCounter: tileCounter,
                        metadata: {
                            applicationVersion: "CAST Database Analyzer v2.0",
                            totalTiles: sourceTiles.size,
                            totalPhones: Array.from(sourceTiles.values()).reduce((sum, tile) => sum + tile.phones.size, 0),
                            totalEmails: Array.from(sourceTiles.values()).reduce((sum, tile) => sum + tile.emails.size, 0),
                            totalIPs: Array.from(sourceTiles.values()).reduce((sum, tile) => sum + tile.ips.size, 0)
                        },
                        tiles: {}
                    };
                    
                    sourceTiles.forEach((tile, tileId) => {
                        saveData.tiles[tileId] = {
                            name: tile.name,
                            files: tile.files,
                            phones: Array.from(tile.phones),
                            emails: Array.from(tile.emails), 
                            ips: Array.from(tile.ips),
                            phoneRows: Object.fromEntries(tile.phoneRows),
                            emailRows: Object.fromEntries(tile.emailRows),
                            ipRows: Object.fromEntries(tile.ipRows),
                            // Enhanced metadata for future compatibility
                            metadata: {
                                createdDate: new Date().toISOString(),
                                fileCount: tile.files.length,
                                extractionMethods: ['Enhanced_Pattern_Matching', 'HTML_Analysis']
                            }
                        };
                    });
                    
                    const jsonString = JSON.stringify(saveData, null, 2);
                    const writable = await fileHandle.createWritable();
                    await writable.write(jsonString);
                    await writable.close();
                    
                    updateStatus('Database saved successfully to selected location');
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        updateStatus('Save cancelled by user');
                        return;
                    }
                    console.error('Save error:', error);
                    // Fallback to legacy download method
                    fallbackSaveDatabase();
                }
            } else {
                // Fallback for browsers without File System Access API
                fallbackSaveDatabase();
            }
        }
        
        function fallbackSaveDatabase() {
            // Legacy download method for browsers without File System Access API
            console.log('Using fallback save method - File System Access API not supported');
            
            const saveData = {
                version: "2.0",
                format: "CAST_JSON", 
                timestamp: new Date().toISOString(),
                tileCounter: tileCounter,
                tiles: {}
            };
            
            sourceTiles.forEach((tile, tileId) => {
                saveData.tiles[tileId] = {
                    name: tile.name,
                    files: tile.files,
                    phones: Array.from(tile.phones),
                    emails: Array.from(tile.emails), 
                    ips: Array.from(tile.ips),
                    phoneRows: Object.fromEntries(tile.phoneRows),
                    emailRows: Object.fromEntries(tile.emailRows),
                    ipRows: Object.fromEntries(tile.ipRows)
                };
            });
            
            const jsonString = JSON.stringify(saveData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `CAST_Database_${new Date().toISOString().replace(/[:.]/g, '-').split('T')[0]}.db`;
            a.click();
            window.URL.revokeObjectURL(url);
            
            updateStatus('Database saved to Downloads folder');
        }

        async function loadDatabase() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.db,.json';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                updateStatus('Loading database...');
                
                try {
                    // First, try to detect if it's a SQLite file by reading the first few bytes
                    const buffer = await file.arrayBuffer();
                    const uint8Array = new Uint8Array(buffer);
                    const header = String.fromCharCode(...uint8Array.slice(0, 16));
                    
                    if (header.startsWith('SQLite format 3')) {
                        // This is a legacy SQLite database - use SQLite compatibility mode
                        console.log('ðŸ—„ï¸ Legacy SQLite database detected - using compatibility mode');
                        await loadLegacySQLiteDatabase(file);
                    } else {
                        // Try to parse as JSON (current format)
                        console.log('ðŸ“„ JSON database detected - using current format parser');
                        const text = await file.text();
                        await loadJSONDatabase(text, file.name);
                    }
                    
                } catch (error) {
                    console.error('Database load error:', error);
                    alert('Error loading database: ' + error.message);
                    updateStatus('Error loading database');
                }
            };
            
            input.click();
        }
        
        async function loadJSONDatabase(text, fileName) {
            const saveData = JSON.parse(text);
            
            // Validate file format
            if (!saveData.tiles) {
                throw new Error('Invalid JSON database file format');
            }
            
            console.log(`ðŸ“Š Loading JSON database version ${saveData.version || '1.0'}`);
            
            // Clear existing data
            sourceTiles.clear();
            
            // Restore counter
            tileCounter = saveData.tileCounter || 0;
            
            // Restore tiles
            Object.entries(saveData.tiles).forEach(([tileId, tileData]) => {
                sourceTiles.set(tileId, {
                    name: tileData.name,
                    files: tileData.files || [],
                    phones: new Set(tileData.phones || []),
                    emails: new Set(tileData.emails || []),
                    ips: new Set(tileData.ips || []),
                    phoneRows: new Map(Object.entries(tileData.phoneRows || {})),
                    emailRows: new Map(Object.entries(tileData.emailRows || {})),
                    ipRows: new Map(Object.entries(tileData.ipRows || {}))
                });
            });
            
            // Rebuild UI
            rebuildUI();
            updateAllAnalysis();
            
            updateStatus(`JSON database loaded successfully - ${Object.keys(saveData.tiles).length} tiles restored`);
        }
        
        async function loadLegacySQLiteDatabase(file) {
            // For SQLite files, we need to use sql.js or similar to read them
            // Since we're in a browser environment, we'll use a different approach
            // We'll ask the user to use a Python script to convert SQLite to JSON first
            
            alert(`ðŸ—„ï¸ Legacy SQLite Database Detected!\n\n` +
                  `This appears to be a legacy SQLite database from the Python version.\n\n` +
                  `To maintain full compatibility, please use the conversion utility:\n\n` +
                  `1. Save this file to convert it: ${file.name}\n` +
                  `2. Run the Python conversion script (provided separately)\n` +
                  `3. Load the converted .json file\n\n` +
                  `This preserves all metadata including IMSI numbers and provider information.`);
            
            updateStatus('Legacy SQLite database detected - conversion required');
            
            // For now, let's create a basic conversion that tries to parse what we can
            // This is a fallback that won't get all the rich metadata but will get basic data
            console.log('âš ï¸ Attempting basic SQLite parsing (limited functionality)');
            
            try {
                // We can't directly parse SQLite in browser without additional libraries
                // But we can provide guidance and potentially implement sql.js if needed
                await attemptBasicSQLiteConversion(file);
            } catch (error) {
                console.error('SQLite conversion attempt failed:', error);
                throw new Error('SQLite file detected but browser cannot parse it directly. Please use the Python conversion utility.');
            }
        }
        
        async function attemptBasicSQLiteConversion(file) {
            // This is a placeholder for potential sql.js integration
            // For now, we'll inform the user about the conversion process
            
            console.log('ðŸ”„ SQLite conversion would require sql.js library integration');
            console.log('ðŸ“ Detected legacy database structure with:');
            console.log('   - sources table (source metadata)');
            console.log('   - phone_numbers table (with IMSI data)');
            console.log('   - email_addresses table');
            console.log('   - ip_addresses table');
            console.log('   - files table (file metadata)');
            
            // For full implementation, we would:
            // 1. Load sql.js library
            // 2. Parse the SQLite file
            // 3. Convert tables to current tile format
            // 4. Preserve all metadata (IMSI, provider info, etc.)
            
            throw new Error('SQLite parsing requires sql.js library - please use conversion utility');
        }

        function rebuildUI() {
            const container = document.getElementById('source-tiles-container');
            container.innerHTML = '';
            
            // Rebuild all tiles
            sourceTiles.forEach((tile, tileId) => {
                container.insertAdjacentHTML('beforeend', createSourceTileHTML(tileId, tile.name));
                
                // Update tile display
                const tileElement = document.getElementById(tileId);
                const fileCount = tileElement.querySelector('.file-count-link');
                const phoneCount = tileElement.querySelector('.phone-count');
                const emailCount = tileElement.querySelector('.email-count');
                const ipCount = tileElement.querySelector('.ip-count');
                const fileList = tileElement.querySelector('.file-list');
                
                fileCount.textContent = tile.files.length;
                phoneCount.textContent = tile.phones.size;
                emailCount.textContent = tile.emails.size;
                ipCount.textContent = tile.ips.size;
                
                // Add file list
                tile.files.forEach(fileName => {
                    const fileDiv = document.createElement('div');
                    fileDiv.className = 'file-list-item';
                    fileDiv.textContent = fileName;
                    fileList.appendChild(fileDiv);
                });
            });
            
            // Add create tile
            createNewCreateTile();
            setupDropZoneListeners();
        }
        
        function exportData(type) {
            let data = [];
            let headers = [];
            
            switch(type) {
                case 'phones':
                    headers = ['Phone Number', 'Sources', 'Count'];
                    sourceData.source1.phones.forEach(phone => {
                        const inSource2 = sourceData.source2.phones.has(phone);
                        data.push([phone, inSource2 ? 'Both' : 'Source 1', inSource2 ? '2+' : '1']);
                    });
                    sourceData.source2.phones.forEach(phone => {
                        if (!sourceData.source1.phones.has(phone)) {
                            data.push([phone, 'Source 2', '1']);
                        }
                    });
                    break;
                    
                case 'emails':
                    headers = ['Email Address', 'Sources', 'Count'];
                    sourceData.source1.emails.forEach(email => {
                        const inSource2 = sourceData.source2.emails.has(email);
                        data.push([email, inSource2 ? 'Both' : 'Source 1', inSource2 ? '2+' : '1']);
                    });
                    sourceData.source2.emails.forEach(email => {
                        if (!sourceData.source1.emails.has(email)) {
                            data.push([email, 'Source 2', '1']);
                        }
                    });
                    break;
                    
                case 'ips':
                    headers = ['IP Address', 'Sources', 'Count'];
                    sourceData.source1.ips.forEach(ip => {
                        const inSource2 = sourceData.source2.ips.has(ip);
                        data.push([ip, inSource2 ? 'Both' : 'Source 1', inSource2 ? '2+' : '1']);
                    });
                    sourceData.source2.ips.forEach(ip => {
                        if (!sourceData.source1.ips.has(ip)) {
                            data.push([ip, 'Source 2', '1']);
                        }
                    });
                    break;
                    
                case 'common':
                    headers = ['Item', 'Type', 'Status'];
                    sourceData.source1.phones.forEach(phone => {
                        if (sourceData.source2.phones.has(phone)) {
                            data.push([phone, 'Phone', 'Common']);
                        }
                    });
                    sourceData.source1.emails.forEach(email => {
                        if (sourceData.source2.emails.has(email)) {
                            data.push([email, 'Email', 'Common']);
                        }
                    });
                    sourceData.source1.ips.forEach(ip => {
                        if (sourceData.source2.ips.has(ip)) {
                            data.push([ip, 'IP', 'Common']);
                        }
                    });
                    break;
            }
            
            // Create CSV
            const csvContent = [headers, ...data]
                .map(row => row.map(field => `"${field}"`).join(','))
                .join('\n');
            
            // Download
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cast-${type}-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
            
            updateStatus(`${type} data exported to CSV`);
        }

        function removeFile(tileId, fileName) {
            const tile = sourceTiles.get(tileId);
            if (!tile) return;
            
            if (confirm(`Remove "${fileName}" from ${tile.name}?`)) {
                // Remove file from tile data
                const fileIndex = tile.files.indexOf(fileName);
                if (fileIndex > -1) {
                    tile.files.splice(fileIndex, 1);
                }
                
                // Remove data that came from this file
                // This is complex because we need to track which data came from which files
                // For now, we'll need to recompute all data for this tile
                
                // Clear all extracted data
                tile.phones.clear();
                tile.emails.clear();
                tile.ips.clear();
                tile.phoneRows.clear();
                tile.emailRows.clear();
                tile.ipRows.clear();
                
                // Re-process remaining files (this is not ideal but ensures data integrity)
                // In a real implementation, we'd track data sources better
                console.log(`File ${fileName} removed. Remaining files would need reprocessing to maintain data integrity.`);
                
                // Update UI - remove the file from display
                const fileListItems = document.querySelectorAll(`#${tileId} .file-list-item`);
                fileListItems.forEach(item => {
                    if (item.querySelector('span').textContent === fileName) {
                        item.remove();
                    }
                });
                
                // Update stats
                const tileElement = document.getElementById(tileId);
                const fileCount = tileElement.querySelector('.file-count-link');
                const phoneCount = tileElement.querySelector('.phone-count');
                const emailCount = tileElement.querySelector('.email-count');
                const ipCount = tileElement.querySelector('.ip-count');
                fileCount.textContent = tile.files.length;
                phoneCount.textContent = tile.phones.size;
                emailCount.textContent = tile.emails.size;
                ipCount.textContent = tile.ips.size;
                
                // Update analysis
                updateAllAnalysis();
                updateStatus(`Removed ${fileName} from ${tile.name}`);
            }
        }

        function deleteTile(tileId) {
            const tile = sourceTiles.get(tileId);
            if (!tile) return;
            
            if (confirm(`Are you sure you want to delete "${tile.name}" and all its files? This cannot be undone.`)) {
                // Remove from data structure
                sourceTiles.delete(tileId);
                
                // Remove from DOM
                const tileElement = document.getElementById(tileId);
                if (tileElement) {
                    tileElement.remove();
                }
                
                // If no tiles left, create a new create tile
                if (sourceTiles.size === 0) {
                    createNewCreateTile();
                }
                
                // Update analysis since data changed
                updateAllAnalysis();
                updateStatus(`Deleted tile: ${tile.name}`);
            }
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear all data?')) {
                // Reset all source tiles
                sourceTiles.clear();
                tileCounter = 0;
                
                // Clear container and add create tile back
                const container = document.getElementById('source-tiles-container');
                container.innerHTML = `
                    <div class="source-tile create-tile" id="create-source-tile">
                        <h3>Create Source Tile</h3>
                        <div class="drop-zone" data-source="create">
                            <p>Drag and drop files here or click to browse</p>
                            <input type="file" multiple accept=".csv,.xlsx,.xls,.txt,.html,.pdf">
                        </div>
                    </div>
                `;
                
                // Clear results
                document.getElementById('phones-results').innerHTML = '';
                document.getElementById('emails-results').innerHTML = '';
                document.getElementById('ips-results').innerHTML = '';
                
                // Re-setup listeners
                setupDropZoneListeners();
                
                updateStatus('All data cleared');
            }
        }

        function performGlobalSearch() {
            const searchTerm = document.getElementById('global-search').value.trim();
            if (!searchTerm) {
                alert('Please enter a search term');
                return;
            }
            
            console.log(`Performing global search for: "${searchTerm}"`);
            updateStatus(`Searching for "${searchTerm}" across all files...`);
            
            const results = [];
            let totalOccurrences = 0;
            
            // Search through all tiles and all their stored row data
            sourceTiles.forEach((tile, tileId) => {
                console.log(`Searching tile: ${tile.name}`);
                
                // Search phone rows
                tile.phoneRows.forEach((rows, phone) => {
                    if (phone.includes(searchTerm) || searchTerm.includes(phone)) {
                        rows.forEach(row => {
                            results.push({
                                type: 'Phone Number',
                                identifier: phone,
                                tile: tile.name,
                                fileName: row.fileName,
                                lineNumber: row.lineNumber,
                                rowData: row.rowData
                            });
                            totalOccurrences++;
                        });
                    }
                });
                
                // Search email rows
                tile.emailRows.forEach((rows, email) => {
                    if (email.toLowerCase().includes(searchTerm.toLowerCase()) || 
                        searchTerm.toLowerCase().includes(email.toLowerCase())) {
                        rows.forEach(row => {
                            results.push({
                                type: 'Email Address',
                                identifier: email,
                                tile: tile.name,
                                fileName: row.fileName,
                                lineNumber: row.lineNumber,
                                rowData: row.rowData
                            });
                            totalOccurrences++;
                        });
                    }
                });
                
                // Search IP rows
                tile.ipRows.forEach((rows, ip) => {
                    if (ip.includes(searchTerm) || searchTerm.includes(ip)) {
                        rows.forEach(row => {
                            results.push({
                                type: 'IP Address',
                                identifier: ip,
                                tile: tile.name,
                                fileName: row.fileName,
                                lineNumber: row.lineNumber,
                                rowData: row.rowData
                            });
                            totalOccurrences++;
                        });
                    }
                });
                
                // Also search raw row data for any other occurrences
                const allRowMaps = [tile.phoneRows, tile.emailRows, tile.ipRows];
                allRowMaps.forEach(rowMap => {
                    rowMap.forEach((rows, identifier) => {
                        rows.forEach(row => {
                            if (row.rowData.toLowerCase().includes(searchTerm.toLowerCase()) &&
                                !results.some(r => r.fileName === row.fileName && 
                                               r.lineNumber === row.lineNumber && 
                                               r.identifier === identifier)) {
                                results.push({
                                    type: 'General Match',
                                    identifier: searchTerm,
                                    tile: tile.name,
                                    fileName: row.fileName,
                                    lineNumber: row.lineNumber,
                                    rowData: row.rowData
                                });
                                totalOccurrences++;
                            }
                        });
                    });
                });
            });
            
            console.log(`Search complete. Found ${totalOccurrences} occurrences in ${results.length} unique locations`);
            
            if (results.length === 0) {
                alert(`No results found for "${searchTerm}"`);
                updateStatus('Search completed - no results found');
                return;
            }
            
            // Show search results in modal instead of immediately exporting
            showGlobalSearchModal(searchTerm, results, totalOccurrences);
            updateStatus(`Found ${totalOccurrences} occurrences of "${searchTerm}" across ${results.length} locations`);
        }
        
        function exportSearchResults(searchTerm, results) {
            // Group results by identifier type
            const groupedResults = {};
            results.forEach(result => {
                const key = `${result.type}: ${result.identifier}`;
                if (!groupedResults[key]) {
                    groupedResults[key] = [];
                }
                groupedResults[key].push(result);
            });
            
            // Create CSV content
            const headers = ['Search Term', 'Type', 'Identifier', 'Tile', 'File Name', 'Line Number', 'Row Data'];
            const csvContent = [headers, ...results.map(result => [
                searchTerm,
                result.type,
                result.identifier,
                result.tile,
                result.fileName,
                result.lineNumber,
                result.rowData
            ])]
                .map(row => row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(','))
                .join('\n');
            
            // Download CSV
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `global_search_${searchTerm.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        // Add Enter key support for search
        document.addEventListener('DOMContentLoaded', () => {
            const searchInput = document.getElementById('global-search');
            if (searchInput) {
                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        performGlobalSearch();
                    }
                });
            }
        });

        function closeSearchModal() {
            document.getElementById('searchModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.addEventListener('click', (e) => {
            const searchModal = document.getElementById('searchModal');
            if (e.target === searchModal) {
                closeSearchModal();
            }
        });

        function showPhoneSearchModal(phone) {
            console.log(`Showing search modal for phone: ${phone}`);
            const searchData = collectPhoneOccurrences(phone);
            showSearchModal('Phone Number', phone, searchData);
        }

        function showEmailSearchModal(email) {
            console.log(`Showing search modal for email: ${email}`);
            const searchData = collectEmailOccurrences(email);
            showSearchModal('Email Address', email, searchData);
        }

        function showIPSearchModal(ip) {
            console.log(`Showing search modal for IP: ${ip}`);
            const searchData = collectIPOccurrences(ip);
            showSearchModal('IP Address', ip, searchData);
        }

        function collectPhoneOccurrences(phone) {
            const occurrences = {};
            let totalCount = 0;

            sourceTiles.forEach((tile, tileId) => {
                if (tile.phoneRows.has(phone)) {
                    const rows = tile.phoneRows.get(phone);
                    if (!occurrences[tile.name]) {
                        occurrences[tile.name] = {};
                    }
                    
                    rows.forEach(row => {
                        if (!occurrences[tile.name][row.fileName]) {
                            occurrences[tile.name][row.fileName] = 0;
                        }
                        occurrences[tile.name][row.fileName]++;
                        totalCount++;
                    });
                }
            });

            return { occurrences, totalCount, identifier: phone, type: 'phone' };
        }

        function collectEmailOccurrences(email) {
            const occurrences = {};
            let totalCount = 0;

            sourceTiles.forEach((tile, tileId) => {
                if (tile.emailRows.has(email)) {
                    const rows = tile.emailRows.get(email);
                    if (!occurrences[tile.name]) {
                        occurrences[tile.name] = {};
                    }
                    
                    rows.forEach(row => {
                        if (!occurrences[tile.name][row.fileName]) {
                            occurrences[tile.name][row.fileName] = 0;
                        }
                        occurrences[tile.name][row.fileName]++;
                        totalCount++;
                    });
                }
            });

            return { occurrences, totalCount, identifier: email, type: 'email' };
        }

        function collectIPOccurrences(ip) {
            const occurrences = {};
            let totalCount = 0;

            sourceTiles.forEach((tile, tileId) => {
                if (tile.ipRows.has(ip)) {
                    const rows = tile.ipRows.get(ip);
                    if (!occurrences[tile.name]) {
                        occurrences[tile.name] = {};
                    }
                    
                    rows.forEach(row => {
                        if (!occurrences[tile.name][row.fileName]) {
                            occurrences[tile.name][row.fileName] = 0;
                        }
                        occurrences[tile.name][row.fileName]++;
                        totalCount++;
                    });
                }
            });

            return { occurrences, totalCount, identifier: ip, type: 'ip' };
        }

        function showGlobalSearchModal(searchTerm, results, totalOccurrences) {
            const modal = document.getElementById('searchModal');
            const modalTitle = document.getElementById('search-modal-title');
            const summary = document.getElementById('search-summary');
            const resultsList = document.getElementById('search-results-list');
            const exportBtn = document.getElementById('export-search-results-btn');
            
            // Set title
            modalTitle.textContent = `Global Search: ${searchTerm}`;
            
            // Group results by tile
            const tileGroups = {};
            results.forEach(result => {
                if (!tileGroups[result.tile]) {
                    tileGroups[result.tile] = {};
                }
                if (!tileGroups[result.tile][result.fileName]) {
                    tileGroups[result.tile][result.fileName] = 0;
                }
                tileGroups[result.tile][result.fileName]++;
            });
            
            const tileCount = Object.keys(tileGroups).length;
            
            // Set summary
            summary.innerHTML = `
                <strong>Found in ${tileCount} source tile${tileCount > 1 ? 's' : ''}</strong><br>
                <strong>Total occurrences: ${totalOccurrences}</strong>
            `;
            
            // Build results list
            resultsList.innerHTML = '';
            Object.entries(tileGroups).forEach(([tileName, files]) => {
                const tileDiv = document.createElement('div');
                tileDiv.className = 'search-result-tile';
                
                const fileCount = Object.keys(files).length;
                const occurrenceCount = Object.values(files).reduce((sum, count) => sum + count, 0);
                
                tileDiv.innerHTML = `
                    <h4>${tileName} (${fileCount} file${fileCount > 1 ? 's' : ''}, ${occurrenceCount} occurrence${occurrenceCount > 1 ? 's' : ''})</h4>
                `;
                
                Object.entries(files).forEach(([fileName, count]) => {
                    const fileDiv = document.createElement('div');
                    fileDiv.className = 'search-result-file';
                    fileDiv.textContent = `${fileName}: ${count} occurrence${count > 1 ? 's' : ''}`;
                    tileDiv.appendChild(fileDiv);
                });
                
                resultsList.appendChild(tileDiv);
            });
            
            // Set up export button
            exportBtn.onclick = () => {
                exportSearchResults(searchTerm, results);
                closeSearchModal();
            };
            
            // Show modal
            modal.style.display = 'block';
        }

        function showSearchModal(itemType, identifier, searchData) {
            const modal = document.getElementById('searchModal');
            const modalTitle = document.getElementById('search-modal-title');
            const summary = document.getElementById('search-summary');
            const resultsList = document.getElementById('search-results-list');
            const exportBtn = document.getElementById('export-search-results-btn');
            
            // Set title
            modalTitle.textContent = `${itemType}: ${identifier}`;
            
            // Set summary
            const tileCount = Object.keys(searchData.occurrences).length;
            summary.innerHTML = `
                <strong>Found in ${tileCount} source tile${tileCount > 1 ? 's' : ''}</strong><br>
                <strong>Total occurrences: ${searchData.totalCount}</strong>
            `;
            
            // Build results list
            resultsList.innerHTML = '';
            Object.entries(searchData.occurrences).forEach(([tileName, files]) => {
                const tileDiv = document.createElement('div');
                tileDiv.className = 'search-result-tile';
                
                const fileCount = Object.keys(files).length;
                const occurrenceCount = Object.values(files).reduce((sum, count) => sum + count, 0);
                
                tileDiv.innerHTML = `
                    <h4>${tileName} (${fileCount} file${fileCount > 1 ? 's' : ''}, ${occurrenceCount} occurrence${occurrenceCount > 1 ? 's' : ''})</h4>
                `;
                
                Object.entries(files).forEach(([fileName, count]) => {
                    const fileDiv = document.createElement('div');
                    fileDiv.className = 'search-result-file';
                    fileDiv.textContent = `${fileName}: ${count} occurrence${count > 1 ? 's' : ''}`;
                    tileDiv.appendChild(fileDiv);
                });
                
                resultsList.appendChild(tileDiv);
            });
            
            // Set up export button
            exportBtn.onclick = () => {
                if (searchData.type === 'phone') {
                    exportPhoneRows(searchData.identifier);
                } else if (searchData.type === 'email') {
                    exportEmailRows(searchData.identifier);
                } else if (searchData.type === 'ip') {
                    exportIPRows(searchData.identifier);
                }
                closeSearchModal();
            };
            
            // Show modal
            modal.style.display = 'block';
        }
    </script>
    
    <!-- Input Modal for Tile Names -->
    <div id="inputModal" class="input-modal">
        <div class="input-modal-content">
            <h3 id="input-modal-title">Enter Tile Name</h3>
            <input type="text" id="input-modal-field" placeholder="Enter name..." />
            <div class="input-modal-buttons">
                <button class="btn btn-cancel" onclick="closeInputModal()">Cancel</button>
                <button class="btn" onclick="confirmInputModal()">Create</button>
            </div>
        </div>
    </div>
</body>
</html>